{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#is-krux-a-hardware-wallet","title":"Is Krux a hardware wallet?","text":"<p>The term \"hardware wallet\" typically refers to devices dedicated to storing private keys and signing transactions. These devices often feature specific security components like secure element chips.</p> <p>Krux was initially developed as a signer, operating exclusively in amnesic mode, which requires users to load their keys each time the device is powered on. However, Krux has evolved and now offers the option to store mnemonics, similar to traditional hardware wallets. These mnemonics can be stored in the device's internal memory or on SD cards.</p> <p>Krux does not include hardware secure elements. The security of stored data relies on encryption. Read more about Krux Encryption - Regarding BIP39 Mnemonics.</p> <p>Note: Due to the inherent fragility of electronic components, never use your Krux device or SD card encrypted storage as your sole backup method. Always maintain a physical backup for added security.</p>"},{"location":"faq/#what-is-the-test-beta-version","title":"What is the test (beta) version?","text":"<p>The test (beta) version includes the latest and most experimental features, which we occasionally share on our social media. The firmware can be found exclusively in the test (beta) repository. Use and flash the beta firmware if you are curious about new features or want to participate in the development process by hunting bugs, providing feedback, and sharing ideas in our Telegram groups or other social media platforms.</p> <p>Just remember that for regular use, use the official versions, which are signed, thoroughly tested, and well documented.</p>"},{"location":"faq/#what-is-krux-mobile-android-app","title":"What is Krux Mobile Android app?","text":""},{"location":"faq/#how-can-i-find-it","title":"How can I find it?","text":"<p>The Krux Mobile Android app is considered a test (beta) and is available as an APK at KruxMobileApp. It requires Android 6.0 or above.</p>"},{"location":"faq/#how-can-i-install-it","title":"How can I install it?","text":"<p>The APK is not available on the Play Store. You can download the APK directly or transfer it to your Android device via SD card or USB cable. To install it, you may need to configure your Android device to allow installations from unknown sources.</p>"},{"location":"faq/#is-it-safe-to-use","title":"Is it safe to use?","text":"<p>The Krux Mobile Android app is designed for learning about Krux and Bitcoin air-gapped transactions. Due to the numerous potential vulnerabilities inherent in smartphones, such as the lack of control over the operating system, libraries, and hardware peripherals, the Krux app should NOT be used to manage wallets containing savings or important keys and mnemonics. For secure management of your keys, a dedicated device is recommended.</p>"},{"location":"","title":"Krux","text":"<p>Krux is an open-source firmware that transforms off-the-shelf Kendryte K210 devices, such as the Maix Amigo, M5StickV and more, into versatile bitcoin transaction signers. Beyond its core functionality, Krux is a flexible platform that can adapt to devices with different form factors, providing a suite of tools to assist with the creation and recovery of mnemonic backups, some of which include encryption options for enhanced security.</p> <p>Devices like the Maix Amigo, Yahboom, WonderMV or TZT come ready to use, with large touchscreens that make it easy and user-friendly to operate. These devices are ideal for those looking for a plug-and-play solution. On the other hand, Krux also supports development board kits, which are perfect for DIY enthusiasts who enjoy customizing and building their own hardware setups.</p> <p>Interacting seamlessly with leading coordinator wallets through QR codes, SD cards, and even thermal printers, the user-friendly firmware offers unique features to support transactions and mnemonic backups in an offline environment.</p> <p>To learn more about Krux, check out Getting Started.</p>"},{"location":"parts/","title":"Devices and Parts List","text":""},{"location":"parts/#compatible-devices-comparative-table","title":"Compatible Devices (comparative table)","text":"Device M5StickV Maix Amigo Maix Dock Yahboom k210 module Maix Cube WonderMV TZT Price range US$ 50-55 US$ 50-85 US$ 27-35 US$ 45-61 US$ 34-49 US$ 58-86 US$ 48 Screen size / resolution 1.14\" / 135*240 3.5\" / 320*480 2.4\" / 240*320 2\" / 240*320 1.3\" / 240*240 2\" / 240*320 2\" / 240*320 Brightness control Device size 48*24*22mm 104*63*17mm 98*59*18mm 57*41*17mm 40*40*16mm 59*41*17mm 57*41*16mm Touchscreen Capacitive Capacitive Capacitive Capacitive Camera <code>OV7740</code> <code>OV7740</code> rear<code>GC0328</code> front <code>GC0328</code> <code>OV2640</code> (VER:1.0) or<code>GC2145</code> (VER:1.1) <code>OV7740</code> <code>GC2145</code> <code>GC2145</code> or<code>GC0328</code> Battery 200mAh 520mAh 200mAh Requirements None None Rotary encoder 3D printed case SolderingAssembly None None None None Warnings Micro USB 3-Way button None <p>: The USB-C ports on the M5StickV and WonderMV lack the pull-up resistors required for host (computer) recognition and power. If you don't have a USB-A port available, you can use a USB hub between your computer's USB-C port and these devices. </p> <p>: Some Amigo screens have inverted X coordinates, others display colors differently. For more info see Troubleshooting. <p></p> <p>: Some Maix Dock units are shipped with soldered pin connectors, which prevent them from fitting into the 3D-printed case. Certain boards also come with built-in Wi-Fi.  </p> <p>: WonderMV may restart when certain SD cards are inserted. See Why does my WonderMV reboot. </p> <p>All devices feature Kendryte K210 chip: 28nm process, dual-core RISC-V 64bit @400MHz, 8 MB high-speed SRAM, DVP camera and MCU LCD interface, AES Accelerator, SHA256 Accelerator, FFT Accelerator. </p>"},{"location":"parts/#m5stickv","title":"M5StickV","text":"<p>Krux was first ported to this device in March 2022. Featuring the smallest screen size and resolution, it also includes a built-in battery. Refer to the USB-C recognition warning  above for important notes. Below is a list of distributors where it can be found: <ul> <li>M5Stack</li> <li>Mouser</li> <li>Digi-Key</li> <li>Electromaker</li> <li>Lee's Electronic</li> <li>AliExpress</li> <li>Alibaba</li> <li>ABRA</li> <li>Adafruit</li> <li>Cytron</li> </ul>"},{"location":"parts/#maix-amigo","title":"Maix Amigo","text":"<p>Krux has supported this device since its second version in August 2022. It offers the largest screen size and resolution, a touchscreen, and a built-in battery. Below is a list of distributors where it is available:</p> <ul> <li>AliExpress</li> <li>Seeed Studio</li> <li>Digi-Key</li> <li>Mouser</li> <li>Electromaker</li> <li>\u30b9\u30a4\u30c3\u30c1\u30b5\u30a4\u30a8\u30f3\u30b9</li> </ul>"},{"location":"parts/#yahboom-k210-module","title":"Yahboom k210 module","text":"<p>Supported by Krux since March 2024, this device features a touchscreen and comes with a compatible 32 GB card, a USB card reader, one PH2.0 4-pin male-to-male connector, and a PH2.0 female adapter for connecting to a thermal printer. Below is a list of distributors where it is available:</p> <ul> <li>AliExpress</li> <li>Amazon</li> <li>Yahboom Store</li> <li>ETC HK Shop</li> </ul>"},{"location":"parts/#maix-cube","title":"Maix Cube","text":"<p>Supported by Krux since July 2024, this device features the second smallest screen size and resolution, a 3-way button, and a built-in battery. Below is a list of distributors where it is available:</p> <ul> <li>Seeed Studio</li> <li>Mouser</li> <li>Electromaker</li> <li>Digi-Key</li> <li>AliExpress</li> <li>Amazon</li> </ul>"},{"location":"parts/#wondermv","title":"WonderMV","text":"<p>Supported by Krux since September 2024, this touchscreen device features a metal backplate and includes a compatible 32 GB card, a USB card reader, and two 5264 4-pin connector male-to-male cables for connecting to a thermal printer. Refer to the USB-C recognition warning  and the SD card warning  above for important notes. The following distributors offer this device: <ul> <li>AliExpress</li> <li>Amazon</li> <li>Hiwonder Store</li> <li>Ruten</li> <li>\u98c6\u6a5f\u5668\u4eba</li> </ul>"},{"location":"parts/#tzt","title":"TZT","text":"<p>Supported by Krux since October 2025, this touchscreen device comes in a premium milled aluminum housing and features five buttons. Available through the following distributors:</p> <ul> <li>AliExpress</li> </ul>"},{"location":"parts/#maix-dock","title":"Maix Dock","text":"<p>For DIY enthusiasts, Krux has supported the Maix Dock since August 2022. These kits include a board and screen but require you to source a rotary encoder or buttons separately and assemble the device yourself. Some Maix Dock boards also include Wi-Fi.</p> <p>Here are example builds with instructions on how to recreate them:</p> <ul> <li>https://github.com/selfcustody/DockEncoderCase</li> </ul> <p>Available from these distributors:</p> <ul> <li>Mouser</li> <li>Electromaker</li> <li>Digi-Key</li> <li>AliExpress</li> <li>Amazon</li> </ul>"},{"location":"parts/#other-parts","title":"Other Parts","text":""},{"location":"parts/#usb-c-or-micro-usb-charge-cable","title":"USB-C or Micro USB Charge Cable","text":"<p>This will come with the device. It will be necessary to power, charge the device (if it has battery) and to initially flash the firmware.</p>"},{"location":"parts/#optional-microsd-card","title":"(Optional) MicroSD Card","text":"<p>We cannot guarantee that a microSD card is compatible and will work in your device; you'll need to test it on the device to be sure, read the Troubleshooting for more info. Yahboom will come with a compatible 32G card. The size of the SD card isn't important; anything over a few megabytes will be plenty.</p>"},{"location":"parts/#optional-ttl-serial-thermal-printer","title":"(Optional) TTL Serial Thermal Printer","text":"<p>Warning/Disclaimer: This feature is intended for individuals with experience in electronics tinkering and soldering.</p> <p>Krux has the capability to print all QR codes it generates, including those for mnemonics, xpubs, wallet backups, and signed PSBTs, using a locally-connected thermal printer via its serial port.</p> <p>Many TTL serial thermal printers may be compatible, but currently, the Goojprt QR203 has the best support (except this printer only supports ASCII or Chinese characters, non-ASCII characters will be printed as Chinese). The Adafruit printer starter pack can also be a convenient option to get started, as it includes all the necessary components for printing (except the conversion cable). To ensure proper functionality, enable the printer driver in settings, set the Tx pin and baud rate value to either 19200 or 9600 (depends on the printer), as explained in this Adafruit printer tutorial. You will need to connect the device's Tx to the printer's Rx and device's ground to the printer's ground, do not connect any other pins because a wrong connection may damage your device. The printer requires a dedicated power supply, typically with an output of 5 to 9V (or 12V) and capable of supplying at least 2A. For more information, see this discussion.</p>"},{"location":"parts/#conversion-cable","title":"Conversion Cable","text":"<p>To connect the printer to M5StickV, Amigo or Cube, you will need a grove conversion cable with a 4-pin male Grove connector on one end (to connect to the device) and 4-pin male jumpers on the other end (to connect to the printer). Check your device and printer model connection first, Yahboom comes with PH2.0 4Pin female connector; Dock doesn't have a connector; WonderMV comes with Molex 51004 4-pin connector (used with smart servo). For a more reliable connection, it is recommended to cut and solder the wires of your custom cables instead of using jumpers. Here we have a description of some inter-integrated circuit (I2C) connector standards.</p>"},{"location":"support/","title":"Support the Project","text":""},{"location":"support/#ways-you-can-help","title":"Ways you can help","text":""},{"location":"support/#development","title":"Development","text":"<p>Audit the code, file an issue, make a pull request, or do all three .</p>"},{"location":"support/#documentation","title":"Documentation","text":"<p>\"I'd like to see Krux help as many people as possible, and to do that, good documentation is needed. If you identify a better way to say something, please make a PR, any help is appreciated.\" - Jeff</p>"},{"location":"support/#translation","title":"Translation","text":"<p>Krux supports different languages. If you missed a language or saw an awkward translation, open an issue or make a PR! You can also make a difference by translating this documentation! For information on how to translate, see here</p>"},{"location":"support/#social","title":"Social","text":"<p>Reach out via our Telegram group or X profile (Twitter) for faster help, share ideas and join the Krux community. Help others get to know Krux.</p> <p>\"I'm an engineer, not a marketer. If you like Krux, help spread the word!\" - Jeff</p>"},{"location":"support/#krux-ethos","title":"Krux Ethos","text":"<p>The purpose of this ethos is not to virtue signal, but to introduce newcomers to Krux's philosophy and provide a guiding reference for decision-making and the long-term mission for dedicated Krux users.</p>"},{"location":"support/#mission","title":"Mission","text":"<p>To implement ideas that make self-custody more powerful, accessible, and user-friendly.</p>"},{"location":"support/#dont-trust-verify","title":"Don't Trust, Verify","text":"<p>Do not trust developers\u2019 intentions or competence. Krux is a DIY, use-at-your-own-risk project. We are committed to continuously improving security, but will not make claims or create marketing narratives about it. It is up to the users verify their hardware, the firmware and Krux-Installer</p>"},{"location":"support/#donations","title":"Donations","text":"<p>Krux will not solicit, receive, manage, or distribute donations. Therefore, Krux has no budget for publicity, audits, or similar activities. Contributors to Krux will fund their own work\u2014whether by promoting their efforts, applying for grants, or seeking direct individual donations.</p>"},{"location":"support/#krux-is-public-domain","title":"Krux is Public Domain","text":"<p>Krux users should feel completely free from any obligation to donate or support developers. Use Krux without guilt or expectation.</p> <p>The same applies to any company profiting from Krux-based products or services, such as educational content, custom hardware, or accessories. The \"don't trust\" principle clearly extends here as well\u2014it is the users\u2019 responsibility to determine if these products align with the Krux ethos and their personal values.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#before-installing","title":"Before Installing","text":""},{"location":"troubleshooting/#linux-os-not-listing-serial-port","title":"Linux OS not listing serial port?","text":"<p>If you get the following error when trying to flash your device: <code>Failed to find device via USB. Is it connected and powered on?</code> Make sure your device is being detected and serial ports are being mounted by running: <pre><code>ls /dev/ttyUSB*\n</code></pre> Expect one port to be listed for devices like M5StickV and Maix Dock <code>/dev/ttyUSB0</code>, and two ports for Maix Amigo <code>/dev/ttyUSB0  /dev/ttyUSB1</code>.</p> <p>If you don't see them, your OS may not be loading the correct drivers to create the serial ports to connect to. Ubuntu has a known bug where the <code>brltty</code> driver \"kidnaps\" serial devices. You can solve this problem by removing it: <pre><code>sudo apt-get remove brltty\n</code></pre></p>"},{"location":"troubleshooting/#device-not-charging-or-being-recognized","title":"Device not charging or being recognized?","text":"<p>If you have a Maix Amigo, make sure you're using the USB-C port at the bottom of the device, not the one on the left side.</p> <p>Different computer hosts have varying hardware, operating systems, and behaviors regarding connecting to their USB ports. Below are the expected behaviors:</p> <p>USB-A:</p> <p>Your device should charge and turn on when connected to a USB-A port, even if it was initially turned off. You can also turn off the device while it continues to charge. However, some hosts' USB-A ports may behave like USB-C ports, as described below.</p> <p>USB-C:</p>"},{"location":"troubleshooting/#m5stickv-wondermv","title":"M5StickV, WonderMV","text":"<p>The USB-C ports on the M5StickV and WonderMV lack the pull-up resistors required for host (computer) recognition and power. If you don't have a USB-A port available, you can use a USB hub between your computer's USB-C port and these devices.</p>"},{"location":"troubleshooting/#maix-amigo-cube","title":"Maix Amigo, Cube","text":"<ul> <li> <p>If the device is turned off and connected to a USB-C port, it should turn on and start charging. You can turn it off again, and it will continue to charge.</p> </li> <li> <p>If the device is already turned on and connected to a USB-C port, it may not charge or be recognized by the computer. In this case, turn off the device to initiate recognition and charging. Once turned off and reconnected, the device should restart, be recognized by the computer, and charging should be triggered by USB-C hosts. If your device is not charging or being recognized as expected, try using a different USB port or a different computer to determine if the issue is with the device or the host's USB port.</p> </li> </ul>"},{"location":"troubleshooting/#device-randomly-freezes-or-restarts","title":"Device randomly freezes or restarts?","text":"<p>If the device behaves this way when connected to the computer, Windows is known to have issues with USB-C devices. If you are experiencing random crashes or even reboots and your device does not have a battery, try using a phone charger or other power source such as a power bank.</p>"},{"location":"troubleshooting/#error-when-flashing","title":"Error when flashing","text":"<p>If flashing fails with an error: <code>Greeting fail, check serial port (SLIP receive timeout (wait frame start))</code> or <code>[ERROR] No vaild COM Port found in Auto Detect, Check Your Connection or Specify One by --port/-p</code>, double check the command used. Most of devices need to pass the argument <code>-B goE</code> to ktool, but <code>dock</code> and <code>wonder_mv</code> uses the argument <code>-B dan</code> instead. For <code>yahboom</code> you also need to manually specify the port using the <code>-p</code> argument.</p> <p>WonderMV: Some units have a hardware issue that can leave the device in a bad state in which it can't be flashed . If flashing fails, unplug the USB cable, wait 10+ seconds to allow the hardware to fully reset, then reconnect and retry.</p> <p>On Windows, you may encounter the flash failed error when trying to flash Yahboom or WonderMV using Krux-Installer. This means that Windows could not find the driver to communicate with the device via USB (an unrecognized USB Serial will be listed in Device Manager -&gt; Other devices). To fix this, download and install the CH340/341 driver (a USB-SERIAL CH340 will be listed in Device Manager -&gt; Ports (COM &amp; LPT)).</p> <p> </p>"},{"location":"troubleshooting/#after-installing","title":"After Installing","text":""},{"location":"troubleshooting/#maix-amigo-touchscreen-doesnt-work-with-v24030-and-later-but-worked-okay-with-v23091","title":"Maix Amigo touchscreen doesn't work with v24.03.0 and later, but worked okay with v23.09.1?","text":"<p>We added a hardware IRQ (interrupt request) to the firmware, so when you open your Maix Amigo, you will see a switch in the middle of the device board, it must be in the upper position for the touchscreen to work with v24.03.0 and later.</p>"},{"location":"troubleshooting/#troubleshooting-lcd-settings-on-maix-amigo","title":"Troubleshooting LCD Settings on Maix Amigo","text":""},{"location":"troubleshooting/#buttons-in-the-wrong-order","title":"Buttons in the Wrong Order","text":"<p>If the buttons on keypad input screens appear to be in the wrong order, this might be due to inverted X coordinates. To correct this:</p> <ol> <li>Go to Settings -&gt; Hardware -&gt; Display.</li> <li>Change the value of <code>Flipped X Coordinates</code>.</li> </ol>"},{"location":"troubleshooting/#incorrect-colors","title":"Incorrect Colors","text":"<p>If the colors displayed on the interface themes or camera feed are incorrect, you can try the following options:</p> <ul> <li> <p>Inverted Colors: If, for example, the background color is white when it should be black, go to Settings -&gt; Hardware -&gt; Display and toggle <code>Inverted Colors</code>.</p> </li> <li> <p>BGR Colors: If, for example, you are using the Orange theme, and instead of orange the colors appear bluish, Settings -&gt; Hardware -&gt; Display and toggle <code>BGR Colors</code> in the display settings.</p> </li> <li> <p>LCD Type: WARNING! Only try changing this setting if you failed to fix colors with previous ones.</p> <ul> <li> <p>If adjusting <code>Inverted Colors</code> or <code>BGR Colors</code> doesn't fix the incorrect color issue, try changing the <code>LCD Type</code>:</p> <ul> <li>(1) After changing <code>LCD Type</code>, you will be warned that the device will reboot automatically if this change does't resolve the issue.</li> <li>(2) After that, if you see a message prompting you to press the <code>PREVIOUS</code> (UP) button, it means that the new setting worked, if you see a black screen only, it means it failed.</li> <li>(3) If it works but the colors are still wrong, try again with different combinations of <code>Inverted Colors</code> and <code>BGR Colors</code>. This time, you'll likely find a combination that correctly displays the colors of your interface themes and camera feed.</li> </ul> <p>If, after the step (1), the screen turns black and you don't see anything, don't panic, don't press any button, just wait 5 seconds. After 5 seconds the device will automatically reboot with the previous <code>LCD Type</code> setting meaning you should not change this setting and maybe try again with <code>Inverted Colors</code> and <code>BGR Colors</code> only.</p> <p>If you pressed <code>PREVIOUS</code> (UP) and Krux saved the wrong <code>LCD Type</code> setting, you will have to remove all stored settings to see the screen working again. If settings were on SD, remove it from the device and edit or delete the settings manually. If settings were on device's internal memory you will have to wipe it's entire flash memory. You can use the Krux-Installer -&gt; Wipe device feature or type a command on terminal with the device connected. On Linux for example, go to the folder where you downloaded the Krux firmware and use Ktool to fully wipe your device (on other OS use <code>ktool-win.exe</code> or <code>ktool-mac</code>):</p> <pre><code>./ktool-linux -B goE -b 1500000 -E\n</code></pre> <p>Then flash the firmware again using Krux-Installer or by typing on the terminal:</p> <pre><code>./ktool-linux -B goE -b 1500000 maixpy_amigo/kboot.kfpkg\n</code></pre> </li> </ul> </li> </ul>"},{"location":"troubleshooting/#device-does-not-reboot-screen-is-blank-or-stuck-on-logo","title":"Device does not reboot, screen is blank or stuck on logo","text":"<p>If the device didn't reboot after successfully flashing the firmware, or the screen is blank after turning it off and on, or if the device is frozen with the logo on the screen, check if the downloaded file matches your device or try downloading the binaries again, as this could also be due to data corruption.</p> <p>You can also install MaixPy IDE to help with debugging. On its menu go to Tools -&gt; Open Terminal -&gt; New Terminal -&gt; Connect to serial port -&gt; Select a COM port available (if it doesn't work, try another COM port). It will show the terminal and some messages, a message about an empty device or with corrupted firmware appears like: \"interesting, something's wrong, boot failed with exit code 233, go to find your vendor.\"</p>"},{"location":"troubleshooting/#usage","title":"Usage","text":""},{"location":"troubleshooting/#why-isnt-krux-scanning-the-qr-code","title":"Why isn't Krux scanning the QR code?","text":"<p>The screen displays exactly what Krux sees through its camera. If the QR code looks blurry, the lens may be out of focus. You can correct this by gently rotating the lens: turn it counterclockwise (unscrewing to reduce focus distance) or clockwise (screwing to increase focus distance) until the image sharpens. Be aware that the factory may have secured the lens with a small drop of glue, making the first adjustment a bit harder. To rotate the plastic lens ring, use your fingertip, tweezers, or small precision pliers (ideally wrapped with electrical tape to prevent scratches). Once adjusted, future focusing should be much easier.</p> <p>If the lens is already adjusted, the problem may be the distance to the QR code. Hold the device close to the code, then slowly pull it back until the full QR code fits on the screen. Once the code appears sharp and clear, Krux should detect it quickly and respond immediately.</p> <p>Tip: You can hold down the <code>ENTER</code> button of the M5StickV, Maix Amigo or WonderMV to turn on their LED light to potentially increase visibility. All cameras have zoom and anti-glare mode, use anti-glare to capture images from high brightness screens or with incident light. Enable/disable zoom/anti-glare by pressing <code>PAGE</code> button while scanning.</p>"},{"location":"troubleshooting/#error-when-scanning-qr-code","title":"Error when scanning QR code?","text":"<p>If Krux is recognizing that it sees a QR code but is displaying an error message after reading it, the likely reason is that the QR code is not in a format that Krux works with. We have listed the supported formats below:</p> <p>For BIP39 mnemonics:</p> <ul> <li>BIP39 Plaintext (Used by Krux and https://iancoleman.io/bip39/)</li> <li>SeedSigner SeedQR and CompactSeedQR Formats</li> <li>UR Type <code>crypto-bip39</code></li> <li>Encrypted QR Code (Format created by Krux, more information here)</li> </ul> <p>For Wallet output descriptor:</p> <ul> <li>JSON with at least a <code>descriptor</code> key containing an output descriptor string</li> <li>Key-value INI files with at least <code>Format</code>, <code>Policy</code>, and <code>Derivation</code> keys</li> <li>UR Type <code>crypto-output</code></li> </ul> <p>For PSBT (Partially Signed Bitcoin Transactions):</p> <ul> <li>Base43, Base58, and Base64-encoded bytes</li> <li>Raw Bytes</li> <li>UR Type <code>crypto-psbt</code></li> </ul> <p>Additionally, Krux recognizes animated QR codes that use either the plaintext <code>pMofN</code> (the Specter QR format) or binary <code>UR</code> encodings.</p>"},{"location":"troubleshooting/#computer-not-reading-qr-code-that-krux-displays","title":"Computer not reading QR code that Krux displays?","text":"<p>You can toggle brightness of PSBTs QR codes by pressing <code>PAGE</code> or <code>PREVIOUS</code> button. If you are using an M5StickV, the small screen makes it difficult for laptop webcams to capture enough detail to parse the QR codes it displays. For now, a workaround you can do is to take a picture or video of the QR code with a better-quality camera (such as your phone), then enlarge and display the photo or video to your webcam.</p> <p>Alternatively, it may be simpler to use a mobile wallet (BlueWallet or Nunchuk) with the M5StickV since phone cameras don't seem to have issues reading the small QR codes. You can also save the PSBT on a microSD card for Krux to sign and then save the signed PSBT to transfer the file to the computer or phone. Other QR codes displayed by Krux can also be exported as an image to the SD card.</p>"},{"location":"troubleshooting/#why-does-krux-say-the-entropy-of-my-fifty-dice-rolls-does-not-contain-128-bits-of-entropy","title":"Why Does Krux Say the Entropy of My Fifty Dice Rolls Does Not Contain 128 Bits of Entropy?","text":"<p>Please check how entropy measurement works.</p>"},{"location":"troubleshooting/#why-isnt-krux-detecting-my-microsd-card-or-presenting-an-error","title":"Why isn't Krux detecting my microSD card or presenting an error?","text":"<p>Starting from version 23.09.0, Krux supports SD card hot plugging. If you\u2019re using an older version, the SD card may only be detected at boot - so make sure to power off Krux before inserting the microSD card.</p> <p>To check card compatibility, go to Tools -&gt; Device Tests -&gt; Check SD Card. Version 25.10.0 further improved SD card compatibility, so updating may resolve detection issues.</p> <p>Note: Make sure the SD card is using MBR/DOS partition table and FAT32 format, in this video Crypto Guide explains how to do this in Windows. If it is still not detected, try deleting all large files in it.</p>"},{"location":"troubleshooting/#why-does-my-wondermv-reboot-when-i-insert-an-sd-card","title":"Why does my WonderMV reboot when I insert an SD card?","text":"<p>It seems WonderMV has a hardware design issue: It lacks a decoupling capacitor in the circuitry that powers the SD card. Some SD cards may cause the supply voltage to drop when inserted, triggering a reboot.</p> <p>Workarounds:</p> <ul> <li>Insert your SD card before turning on the device, for example, when signing PSBTs, insert the SD card containing the unsigned PSBT before powering WonderMV on and loading your key.</li> <li>Try different SD cards, as some require less current and won't cause the device to reboot.</li> </ul>"},{"location":"video-tutorials/","title":"Video Tutorials","text":"<p>Most people prefer to learn by watching videos, and we are fortunate to have excellent content creators in the Bitcoin space, here are some examples of Krux related content and tutorials.</p>"},{"location":"video-tutorials/#english","title":"English","text":"\u25b6 <p>Krux on M5StickV + Sparrow Wallet - DIY Bitcoin Hardware Wallet (Similar to SeedSigner)</p> <p>Crypto Guide (Jan 2023)</p> <p></p> \u25b6 <p>Krux on Maix Amigo + Blue Wallet - DIY Bitcoin Hardware Wallet (Similar to SeedSigner)</p> <p>Crypto Guide (Dec 2022)</p> <p></p> \u25b6 <p>DIY-Only Multivendor Hardware Wallet MultiSig: SeedSigner, Jade, Krux, Satochip + Sparrow &amp; Electrum</p> <p>Crypto Guide (Sep 2023)</p> <p></p> \u25b6 <p>Krux DIY Bitcoin Signer: Build From Source &amp; Verify (With Windows + WSL2 + Docker)</p> <p>Crypto Guide (Mar 2024)</p> <p></p> \u25b6 <p>BUILD Your Own Bitcoin Hardware Security Device NOW: KRUX</p> <p>BTC Sessions (Mar 2025)</p> <p></p> \u25b6 <p>Bitcoin Security for Under $50: Building a Krux Hardware Wallet</p> <p>Sovereign Money (May 2025)</p> <p></p> \u25b6 <p>Self-Custody Krux Hardware Wallet Tutorial</p> <p>The Bitcoin Hardware Store (Jul 2025)</p>"},{"location":"video-tutorials/#portuguese","title":"Portuguese","text":"\u25b6 <p>Hardwallet Krux f\u00e1cil de instalar + QRs criptografados</p> <p>Bitcoinheiros (Jul 2023)</p> <p></p> \u25b6 <p>Multisig com Krux e Nunchuk no celular</p> <p>Bitcoinheiros (Jul 2023)</p> <p></p> \u25b6 <p>Usando a Krux com impressora t\u00e9rmica</p> <p>Bitcoinheiros (Aug 2023)</p> <p></p> \u25b6 <p>Carteira Bitcoin com celular OFFLINE - Krux mobile APK</p> <p>DIG P2P - Bitcoin Para Iniciantes! (Aug 2023)</p> <p></p> \u25b6 <p>Como instalar a carteira Krux no celular</p> <p>Jo\u00e3o Trein (Feb 2024)</p> <p></p> \u25b6 <p>Fa\u00e7a sua hardware wallet em casa com a KRUX!</p> <p>CAIOVSKI (Jun 2024)</p>"},{"location":"video-tutorials/#korean","title":"Korean","text":"\u25b6 <p>Krux \uc6d4\ub81b \uc124\uce58 \ubc0f \uac80\uc99d \ubc29\ubc95(feat : \uc6d0\ub354\ucf00\uc774 \ube44\ud2b8\ucf54\uc778 \uc804\uc6a9 \ud558\ub4dc\uc6d4\ub81b)</p> <p>\ubd09\ud604\uc774\ud615 (Oct 2024)</p> <p></p> \u25b6 <p>\ub098\ub9cc\uc758 \ube44\ud2b8\ucf54\uc778 \uc9c0\uac11 \ub9cc\ub4e4\uae30(2\uac15_1\ubd80 \uac1c\uc778\ud0a4 \uc0dd\uc131)</p> <p>\ubd09\ud604\uc774\ud615 (Nov 2024)</p> <p></p> \u25b6 <p>\uc548\uc0ac\uba74 \uc190\ud574? \uc138\uc0c1\uc5d0\uc11c \uac00\uc7a5 \ud22c\uba85\ud55c \ube44\ud2b8\ucf54\uc778 \uc804\uc6a9 \uc9c0\uac11(\uc6d0\ub354\ucf00\uc774 \ud558\ub4dc\uc6d4\ub81b)</p> <p>\ubd09\ud604\uc774\ud615 (Oct 2024)</p>"},{"location":"video-tutorials/#chinese","title":"Chinese","text":"\u25b6 <p>1.Krux\u6bd4\u7279\u5e01\u786c\u4ef6\u94b1\u5305\u4ecb\u7ecd</p> <p>\u4e5d\u795e\u4e8c\u53f7 (Jan 2025)</p> <p></p> \u25b6 <p>2.Krux\u6bd4\u7279\u5e01\u786c\u4ef6\u94b1\u5305\u5237\u673a\u6559\u7a0b</p> <p>\u4e5d\u795e\u4e8c\u53f7 (Jan 2025)</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Krux is open-source Bitcoin signing firmware for devices with the K210 chipset; also known as a hardware signer. </p> <p>Signing operations in Krux are done offline via QR code or via SD card using the PSBT functionality. You can create/load your BIP39 mnemonic, or import a wallet descriptor, and sign transactions all without having to plug the device into your computer (except to initially install the firmware). It reads QR codes with its camera and outputs QR codes to its screen, or to paper via an optional thermal printer attachment. </p> <p>Krux runs offline, and therefore never handles the broadcasting part of the PSBT transaction. Instead, you can use Krux with third-party wallet coordinators to broadcast transactions from your online computer or mobile device while keeping your keys offline.</p> <p>These wallet coordinators are currently compatible with Krux:</p> <ul> <li>Sparrow Wallet (desktop)</li> <li>Specter Desktop (desktop)</li> <li>Liana (desktop)</li> <li>Bitcoin Safe (desktop)</li> <li>Nunchuk (mobile)</li> <li>BlueWallet (mobile)</li> <li>Bitcoin Keeper (mobile)</li> <li>BULL Wallet (mobile)</li> </ul> <p>Warning! Krux is INCOMPATIBLE with:</p> <ul> <li>Electrum Bitcoin Wallet (desktop / mobile - error 'cannot sign') </li> </ul>"},{"location":"getting-started/navigation/","title":"Navigation overview","text":"<p>Below is the mind map representation of the currently menus available. Click the circle with a number (Ex.: ) to the right of each node to expand and explore. Also, enable full screen in the top right menu for better viewing .</p>"},{"location":"getting-started/navigation/#login-menu","title":"Login Menu","text":""},{"location":"getting-started/navigation/#home-menu-loaded-a-mnemonic","title":"Home Menu (Loaded a mnemonic)","text":""},{"location":"getting-started/settings/","title":"Settings","text":"<p>In Krux first menu, there is a <code>Settings</code> entry. Some submenu entries have too many options to fit on a single screen, swipe up  or down  to navigate between the screens - if your device has a touchscreen. Below is a breakdown of the options you can change:</p> <p> </p>"},{"location":"getting-started/settings/#default-wallet","title":"Default Wallet","text":"<p>Set the default attributes for wallet loading.</p>"},{"location":"getting-started/settings/#network","title":"Network","text":"<p>This option allows you to switch between <code>mainnet</code> (the default) and <code>testnet</code>. <code>Testnet</code> can be used to try out different wallet coordinators or for development. </p>"},{"location":"getting-started/settings/#policy-type","title":"Policy Type","text":"<p>Choose between <code>Single-sig</code>, <code>Multisig</code>, or <code>Miniscript</code> to avoid having to customize the policy type every time you load a key.</p>"},{"location":"getting-started/settings/#script-type","title":"Script Type","text":"<p>As with <code>Policy Type</code>, pre-select the most commonly used script type so that you don't have to change it every time you load a wallet. Your options are <code>Native Segwit</code>, <code>Neste Segwit</code>, <code>Taproot (Experimental)</code>, and <code>Legacy</code>. If you choose a script type that isn\u2019t implemented for the selected policy type\u2014such as a <code>Legacy</code> script for <code>Miniscript</code>\u2014the system will default to <code>Native Segwit</code>.</p> <p>Note: These settings do not restrict further changes to these wallet attributes, they just set their default values.</p>"},{"location":"getting-started/settings/#encryption","title":"Encryption","text":"<p>Modify the encryption method and parameters to fit your needs. This will be used when storing encrypted mnemonics or creating encrypted QR codes. For more info see Krux Encryption - Regarding BIP39 Mnemonics.</p>"},{"location":"getting-started/settings/#pbkdf2-iter-iterations","title":"PBKDF2 Iter. (Iterations)","text":"<p>When you enter the encryption key, it is not directly used to encrypt your data. In order to protect against brute force attacks, the key is derived multiple times using hashing functions. PBKDF2 (Password-Based Key Derivation Function) iterations stands for the amount of derivations that will be performed over your key prior to encrypt/decrypt your mnemonic.</p> <p>Note: Increasing this value will make the encryption harder, at the cost of taking longer to encrypt/decrypt your mnemonics. Values must be multiple of 10,000 (to save data space on QR codes).</p>"},{"location":"getting-started/settings/#encryption-mode","title":"Encryption Mode","text":"<p>Choose between well known and widely used AES (Advanced Encryption Standard) modes:</p>"},{"location":"getting-started/settings/#aes-ecb","title":"AES-ECB","text":"<p>ECB (Electronic Codebook) is a simpler method where data blocks are encrypted individually. Compared to CBC, it will be faster and simpler to encrypt, QR codes will have a lower density and will be easier to transcribe.</p>"},{"location":"getting-started/settings/#aes-cbc","title":"AES-CBC","text":"<p>CBC (Cipher-block Chaining) is considered more secure than ECB. The first data block, an initialization vector (IV), is used to add random data to the encryption. The encryption of subsequent blocks depends on the data from previous blocks, ensuring chaining.</p> <p>Encryption will take longer because a snapshot will be needed to generate the IV. This IV will be stored together with the encrypted data, making encrypted QR codes denser and harder to transcribe.</p>"},{"location":"getting-started/settings/#hardware","title":"Hardware","text":"<p>Customize the parameters available for your device and change printer settings.</p>"},{"location":"getting-started/settings/#buttons","title":"Buttons","text":"<p>You can change the debounce threshold in milliseconds. With lower values, faster movements and navigation will be allowed.</p> <p>The caveat is low values can cause issues, such as double click and unexpected movements, especially with lower quality buttons or encoders. If this is the case increase the value to make navigation more stable.</p>"},{"location":"getting-started/settings/#display","title":"Display","text":"<p>Available display settings vary based on your device. Amigo has several options detailed below, Yahboom and WonderMV have an option for flipped orientation, others will have brightness control and Dock does not have this submenu.</p> <p>Few Maix Amigo screens are different, here you can customize the <code>BGR Colors</code>, <code>Flipped X Coordinates</code>, <code>Inverted Colors</code> and <code>LCD Type</code>. For more info see Troubleshooting</p>"},{"location":"getting-started/settings/#printer","title":"Printer","text":"<p>You can set up a TTL serial thermal printer or GRBL. It is also possible to store a GRBL g-code CNC instructions file on an SD card to engrave QR codes.</p>"},{"location":"getting-started/settings/#cnc","title":"CNC","text":"<p>Define several machining parameters according to the desired size, material you'll use, and your CNC characteristics and capabilities. See CNC Engraving for more details.</p>"},{"location":"getting-started/settings/#thermal","title":"Thermal","text":"<p>Printers can come with different baudrates from the manufacturer. By default, Krux assumes the connected printer will have a baudrate of <code>9600</code>. If yours is different, you can change it here.</p> <p>Also setup the TX Pin you'll use (i.e., 35 on M5StickV, 7 on Maix Amigo, 8 on Yahboom, 25 on Cube, 28 on WonderMV) and tweak other parameters according to your printer recommendations. For most printers you will only need to connect 2 cables, the device TX to the printer RX and ground. Current uses of printing are listed here. Consult the parts list for supported printers.</p>"},{"location":"getting-started/settings/#driver","title":"Driver","text":"<p>Here you choose between <code>thermal/adafruit</code>, <code>cnc/file</code>, <code>cnc/grbl</code> or <code>none</code> (default). Leave this setting to <code>none</code> if you won't use a printer and don't want to be bothered by print prompts.</p>"},{"location":"getting-started/settings/#touchscreen-maix-amigo-yahboom-wondermv-and-tzt-only","title":"Touchscreen (Maix Amigo, Yahboom, WonderMV and TZT only)","text":"<p>If your device has touchscreen you can change the touch detection threshold. If it is being too sensitive or detecting false or ghost touches, you should increase the threshold value, making it less sensitive. The other way is also valid, reduce the threshold to make the screen more sensitive to touches.</p> <p>Tip: If your Amigo or WonderMV's touchscreen is not working properly, you can disable it by turning on the device with your finger pressing the screen. This will allow you to operate the device using buttons only.</p>"},{"location":"getting-started/settings/#language-locale","title":"Language - Locale","text":"<p>Here you can change Krux to your language.</p>"},{"location":"getting-started/settings/#persist","title":"Persist","text":"<p>Choose between <code>flash</code> (device's internal memory) or <code>SD card</code> for the place where your settings changes will be stored (default values are not persisted).</p>"},{"location":"getting-started/settings/#security","title":"Security","text":"<p>Adjust settings that may impact your security protocols.</p>"},{"location":"getting-started/settings/#shutdown-time","title":"Shutdown Time","text":"<p>Set the time it takes for Krux to automatically shut down. This feature not only conserves your device's battery, if it has one, but also serves as an important security measure. If you forget your device with private keys loaded, it will shut down automatically after the set time.</p> <p>Note: Devices without batteries and power management will not shut down but reboot, which will also unload keys.</p>"},{"location":"getting-started/settings/#tc-flash-hash-at-boot","title":"TC Flash Hash at Boot","text":"<p>Chose if you would like to run Tamper Check Flash Hash every time the device is powered on.</p> <p>Activating TC Flash Hash at boot helps prevent unauthorized use by requiring the TC Code. But is important to note, unlike a PIN, the TC Code does not provide access control over USB. This means that the device's memory remains accessible via USB, allowing it to be flashed with firmware that does not require the TC Code.</p>"},{"location":"getting-started/settings/#hide-mnemonics","title":"Hide Mnemonics","text":"<p>When <code>True</code>, Krux will disable the New Mnemonic menu and hide the words when Loading a Mnemonic. It will also hide the words when using BIP85 to create a BIP39 Mnemonic and disable the Backup Mnemonic menu.</p>"},{"location":"getting-started/settings/#tamper-check-code","title":"Tamper Check Code","text":"<p>Create or modify a Tamper Check Code. This code will be required every time Tamper Check Flash Hash is executed.</p> <p>After creating the code, you will be prompted to fill the empty memory spaces with random entropy from the camera. This step is important to make TC Flash Hash more resilient to data manipulation by eliminating empty memory spaces that could be exploited in a sophisticated tamper attempt.</p> <p>The filling process requires good entropy images. If, for any reason, such as starting the process in a dark room, you fail to capture good entropy images, you can restart the filling process by resetting your TC Code.</p> <p>The TC Code will be deleted if the device is wiped or user data is erased, which will consequently disable TC Flash Hash.</p>"},{"location":"getting-started/settings/#appearance","title":"Appearance","text":"<p>Configure <code>screensaver time</code> and change Krux to your desired <code>theme</code>.</p>"},{"location":"getting-started/settings/#screensaver-time","title":"Screensaver time","text":"<p>Set how long to wait idle before the screensaver appears. Enter 0 to disable the screensaver.</p>"},{"location":"getting-started/settings/#theme","title":"Theme","text":"<p>Choose your color theme according to your preference. Some themes may be more suitable for some devices, coordinator cameras and environments. As an example, it may be easier to scan QR codes from Krux devices using light theme in brighter environments.</p> <p> </p> <p> </p>"},{"location":"getting-started/settings/#factory-settings","title":"Factory Settings","text":"<p>Restore device to factory settings and reboot.</p>"},{"location":"getting-started/features/QR-transcript-tools/","title":"Transcribing QR Codes","text":"<p>When you export a mnemonic, encrypted mnemonic or a generic text QR code, alternative visualization modes will be available. Swipe left  or right  to change modes, or if your device doesn't have a touchscreen, press the <code>PAGE</code> buttons. See our available transcribe templates.</p>"},{"location":"getting-started/features/QR-transcript-tools/#standard-mode","title":"Standard Mode","text":"<p>This mode is optimized for scanning, the raw QR code will be displayed</p>"},{"location":"getting-started/features/QR-transcript-tools/#lines-mode","title":"Lines Mode","text":"<p>If you are good at transcribing things like handwritten text, with this mode one QR code line will be highlighted at a time. Press <code>ENTER</code> to highlight the next line.</p>"},{"location":"getting-started/features/QR-transcript-tools/#zoomed-regions-mode","title":"Zoomed Regions Mode","text":"<p>QR codes will be split into regions, of 5x5 or 7x7 \"blocks\". One QR code region will be shown at a time. Press <code>ENTER</code> to display the next region.</p>"},{"location":"getting-started/features/QR-transcript-tools/#highlighted-regions-mode","title":"Highlighted Regions Mode","text":"<p>QR codes will be split into regions, of 5x5 or 7x7 \"blocks\". One QR code region will be highlighted at a time. Press <code>ENTER</code> to highlight the next region.</p>"},{"location":"getting-started/features/QR-transcript-tools/#grided-mode","title":"Grided Mode","text":"<p>Grids will be added to a standard QR code. In a dark room, if you place a sheet of paper over the device's screen, you'll notice QR code will be visible and it will be possible to copy it directly from above (tracing). Be careful not to damage your screen with pen and markers, use an insulating plastic tape or film to protect the device when using this method.</p>"},{"location":"getting-started/features/QR-transcript-tools/#qr-viewer","title":"QR Viewer","text":"<p>Almost every QR code in Krux will also bring up this menu with these extra options: <code>Toggle Brightness</code>, <code>Save QR Image to SD Card</code> and <code>Print as QR</code>. If <code>Save QR Image to SD Card</code> shows as disabled it means that the SD card was not detected. To enable <code>Print as QR</code> you need to configure your printer driver in settings.</p>"},{"location":"getting-started/features/entropy/","title":"Empirical Entropy Measurement","text":""},{"location":"getting-started/features/entropy/#why-does-krux-say-the-entropy-of-my-fifty-dice-rolls-does-not-contain-128-bits-of-entropy","title":"Why Does Krux Say the Entropy of My Fifty Dice Rolls Does Not Contain 128 Bits of Entropy?","text":"<p>We want Krux to help users understand the concepts involved in the process, present statistics and indicators, and encourage users to experiment and evaluate results. This way, users learn about best practices in key generation. Below, we delve deeper into the concepts of entropy to better support users' knowledge of sovereign self-custody.</p>"},{"location":"getting-started/features/entropy/#entropy-in-dice-rolls","title":"Entropy in Dice Rolls","text":"<p>Rolling dice and collecting the resulting values can be an effective method for generating cryptographic keys due to the inherent randomness and unpredictability of each roll. Each roll of a die produces a random number within a specific range, and when multiple rolls are combined, they create a sequence that is difficult to predict or reproduce. This sequence can be used to generate cryptographic keys that are robust against attacks. By ensuring that the dice rolls are conducted in a controlled and secure environment, and by using a sufficient number of rolls to achieve the desired level of randomness, one can create cryptographic keys that are highly secure and resistant to brute-force attacks or other forms of cryptanalysis.</p>"},{"location":"getting-started/features/entropy/#entropy-definitions","title":"Entropy Definitions","text":"<p>Entropy, a fundamental concept in various scientific disciplines, is most commonly associated with a state of disorder, randomness, or uncertainty within a system. We use the concepts from thermodynamics entropy, Shannon's entropy, and cryptographic entropy.</p> <ul> <li> <p>Thermodynamics entropy deals with heat and work. It describes how energy is distributed among the particles in a system, reflecting the system's tendency towards equilibrium and maximum disorder.</p> </li> <li> <p>Shannon's entropy, from information theory, measures the uncertainty or information content in a message or data source. It quantifies the average amount of information produced by a stochastic source of data, indicating how unpredictable the data is.</p> </li> <li> <p>Cryptographic entropy, crucial in security, refers to the unpredictability and randomness required for secure cryptographic keys and processes. High cryptographic entropy ensures that keys are difficult to predict or reproduce, providing robustness against attacks.</p> </li> </ul> <p>While thermodynamics entropy deals with physical systems, Shannon's entropy focuses on information content, and cryptographic entropy emphasizes security through randomness.</p>"},{"location":"getting-started/features/entropy/#measuring-dice-rolls-entropy","title":"Measuring Dice Rolls Entropy","text":"<p>Entropy is a theoretical measure and is not directly measurable from a single roll but rather from the probability distribution of outcomes over many rolls. We can use Shannon's formula for theoretical and empirical calculations. Entropy S can be quantified with:</p>  S = -\\sum_{i=1}^{n} p_i \\log(p_i)  <ol> <li> <p>Empirical Measurement:</p> <ul> <li>Roll the dice a large number of times to observe the frequency of each outcome.</li> <li>Estimate the probabilities p_i based on observed frequencies.</li> </ul> </li> <li> <p>Theoretical Calculation:</p> <ul> <li>Use the uniform distribution assumption (equal probability for all outcomes).</li> </ul> </li> </ol> <p>where:</p> <ul> <li>p_i is the probability of each possible outcome (or state) of the system.</li> <li>n is the number of possible outcomes.</li> </ul>"},{"location":"getting-started/features/entropy/#empirical-real-vs-theoretical-entropy-in-dice-rolls","title":"Empirical (Real) vs. Theoretical Entropy in Dice Rolls","text":"<p>When calculating the entropy of dice rolls, the difference between real and theoretical results arises from the assumption of perfect fairness and uniformity versus the inherent imperfections in real-world experiments.</p>"},{"location":"getting-started/features/entropy/#theoretical-entropy","title":"Theoretical Entropy","text":"<p>The theoretical entropy calculation assumes that the dice are perfectly fair, meaning each face has an equal probability of landing face up.</p> <p>Consider a fair six-sided die. The possible outcomes when rolling one die are {1, 2, 3, 4, 5, 6}, each with an equal probability of \\frac{1}{6}.</p> <ol> <li> <p>Single Die Roll:</p> <ul> <li>Each outcome has a probability p_i = \\frac{1}{6}.</li> <li>The entropy S for one die roll is calculated as: $$ S = - \\sum_{i=1}^{6} \\left( \\frac{1}{6} \\log_2 \\left( \\frac{1}{6} \\right) \\right) $$ Since \\log_2(1/6) = -\\log_2(6) : $$ S = -6 \\left( \\frac{1}{6} \\times -\\log_2(6) \\right) = \\log_2(6) \\approx 2.585 \\text{ bits} $$</li> </ul> </li> <li> <p>Multiple Dice Rolls:</p> <ul> <li>For multiple dice, the entropy increases as the number of possible outcomes increases. For k fair dice, the number of possible outcomes is 6^k.</li> <li>The entropy S for k dice is: $$ S = \\log_2(6^k) = k \\log_2(6) \\approx 2.585k \\text{ bits} $$</li> <li>For example, entropy for the roll of 50 fair dice is calculated as: $$ S = \\log_2(6^{50}) = 50 \\log_2(6) \\approx 2.585 \\times 50 \\approx 129.25 \\text{ bits} $$</li> </ul> </li> </ol> <p>This calculation assumes that every outcome (each face of the die) has an equal likelihood, leading to a uniform distribution.</p>"},{"location":"getting-started/features/entropy/#empirical-entropy","title":"Empirical Entropy","text":"<p>In a real sample of dice rolls, several factors can cause deviations from the perfect uniform distribution:</p> <ol> <li>Imperfect Dice: Real dice may not be perfectly balanced. Small manufacturing defects can make certain faces slightly heavier or lighter, causing biases.</li> <li>Rolling Conditions: The way the dice are rolled, the surface they land on, and even air currents can introduce slight biases.</li> <li>Finite Sample Size: When rolling dice a finite number of times, the observed frequencies of each face will naturally deviate from the expected uniform distribution due to random variations. This phenomenon is more pronounced with smaller sample sizes.</li> </ol> <p>When you roll a die multiple times and observe the outcomes, you can calculate the empirical probabilities p_i of each face. Using these probabilities, the entropy is calculated as:</p>  S = - \\sum_{i=1}^{6} p_i \\log_2(p_i)"},{"location":"getting-started/features/entropy/#example","title":"Example","text":"<p>Suppose you roll a six-sided die 50 times and get the following results:</p> <ul> <li>1: 4 times</li> <li>2: 9 times</li> <li>3: 7 times</li> <li>4: 10 times</li> <li>5: 12 times</li> <li>6: 8 times</li> </ul> <p>We can calculate Shannon's entropy as follows:</p>"},{"location":"getting-started/features/entropy/#step-1-calculate-probabilities","title":"Step 1: Calculate Probabilities","text":"<ul> <li>Total number of rolls: $$ N = 4 + 9 + 7 + 10 + 12 + 8 = 50 $$</li> <li>Probabilities for each outcome: $$ p_1 = \\frac{4}{50} = 0.08  $$ $$ p_2 = \\frac{9}{50} = 0.18  $$ $$ p_3 = \\frac{7}{50} = 0.14  $$ $$ p_4 = \\frac{10}{50} = 0.2  $$ $$ p_5 = \\frac{12}{50} = 0.24  $$ $$ p_6 = \\frac{8}{50} = 0.16  $$</li> </ul>"},{"location":"getting-started/features/entropy/#step-2-compute-entropy","title":"Step 2: Compute Entropy","text":"<ul> <li>Using Shannon's entropy formula: $$ S = -\\sum_{i=1}^{n} p_i \\log_2(p_i) $$</li> <li>Calculate each term: $$ S_1 = -p_1 \\log_2(p_1) = -0.08 \\log_2(0.08) = -0.08 \\times (-3.64386) = 0.291509 $$ $$ S_2 = -p_2 \\log_2(p_2) = -0.18 \\log_2(0.18) = -0.18 \\times (-2.47393) = 0.445307 $$ $$ S_3 = -p_3 \\log_2(p_3) = -0.14 \\log_2(0.14) = -0.14 \\times (-2.8365) = 0.39711 $$ $$ S_4 = -p_4 \\log_2(p_4) = -0.2 \\log_2(0.2) = -0.2 \\times (-2.32193) = 0.464386 $$ $$ S_5 = -p_5 \\log_2(p_5) = -0.24 \\log_2(0.24) = -0.24 \\times (-2.05889) = 0.494132 $$ $$ S_6 = -p_6 \\log_2(p_6) = -0.16 \\log_2(0.16) = -0.16 \\times (-2.64386) = 0.423018 $$</li> <li> <p>Sum the contributions: $$ S = S_1 + S_2 + S_3 + S_4 + S_5 + S_6  $$ $$ S = 0.291509 + 0.445307 + 0.39711 + 0.464386 + 0.494132 + 0.423018 = 2.515462 $$ Thus, the Shannon's entropy for the given distribution of dice rolls is approximately 2.52 bits per roll. This will give you a different value than \\log_2(6) due to the deviations in the empirical probabilities.</p> </li> <li> <p>The total entropy for the N = 50 rolls is: $$ S_{total} = S \\times N = 2.515 + 50 \\approx 125.8 \\text{ bits} $$</p> </li> </ul>"},{"location":"getting-started/features/entropy/#shannons-entropy-in-practice","title":"Shannon's Entropy in Practice","text":"<p>Calculating Shannon's entropy on a real sample of dice rolls provides insights into the actual randomness and fairness of the dice and rolling conditions. Deviations from the theoretical entropy reflect the natural imperfections and variances inherent in real-world scenarios. This understanding helps in evaluating and improving the fairness and randomness of dice or similar systems.</p> <p>Shannon's entropy evaluates the statistical probability distribution of samples of a dice roll. An even distribution results in higher entropy, closer to the theoretical maximum entropy, which assumes perfectly distributed rolls. An uneven distribution, created, for example, by a biased die, will result in lower Shannon's entropy. In an extreme case, with a terribly biased die that always lands on the same side, Shannon's entropy will be zero.</p>"},{"location":"getting-started/features/entropy/#cryptographic-entropy","title":"Cryptographic Entropy","text":"<p>Shannon's entropy, while a powerful measure of information content and uncertainty in a statistical distribution for natural samples, is not considered cryptographic entropy due to its inability to detect patterns or other sources of predictability within data. Shannon's formula quantifies the average information produced by a stochastic process, essentially measuring the expected surprise in a sequence of symbols based on their probabilities. However, it does not account for potential structure, correlations, or regularities within the data that could be inserted by a user and exploited by an attacker.</p> <p>Cryptographic entropy, on the other hand, requires a higher standard of unpredictability. It must ensure that every bit of the cryptographic key is as random and independent as possible, making it resilient against any form of analysis that could reveal patterns or reduce the effective randomness. While Shannon's entropy can evaluate the statistical distribution of symbols, it falls short in guaranteeing the absence of patterns or dependencies, which are crucial for maintaining the security of cryptographic systems. Thus, cryptographic entropy encompasses a broader concept of randomness, ensuring that the generated keys are not only statistically random but also free from any detectable structure or predictability.</p>"},{"location":"getting-started/features/entropy/#pattern-detection","title":"Pattern Detection","text":"<p>It is possible to have dice rolls with an even distribution but poor cryptographic entropy. This issue arises when patterns are present in the sequences. Examples include sequences like <code>123456123456123...</code>, <code>111122223333...</code>, and <code>654321654321...</code>, which exhibit poor cryptographic entropy despite having even distribution and high Shannon's entropy.</p> <p>To mitigate this issue, Krux has implemented a pattern detection algorithm that evaluates the Shannon's entropy of the rolls' derivatives. In practice, this algorithm detects arithmetic progression components in the dice rolls and raises a warning if a certain threshold is crossed.</p>"},{"location":"getting-started/features/entropy/#what-krux-does","title":"What Krux Does?","text":"<ul> <li>Krux requires a minimum number of rolls based on theoretical entropy.</li> <li>Krux warns the user if low Shannon's entropy, calculated with the actual rolls, is detected.</li> <li>Krux warns the user if it suspects there are patterns within the actual rolls.</li> </ul>"},{"location":"getting-started/features/entropy/#conclusion","title":"Conclusion","text":"<p>While Krux cannot ensure rolls have good or bad cryptographic entropy, it does provide indicators to help users detect issues and learn about the concepts involved in mnemonic generation.</p>"},{"location":"getting-started/features/mnemonic-xor/","title":"What is Mnemonic XOR?","text":"<p>It is an implementation of the XOR (exclusive OR) operation across the entropy values of two or more mnemonics to produce a combined result, based on Coinkite's SeedXOR.</p>"},{"location":"getting-started/features/mnemonic-xor/#how-it-works","title":"How It Works","text":"<p>Krux derives a new mnemonic (and therefore a new seed) by performing an XOR operation on the entropy bytes of the source mnemonics. The result of this XOR operation is a new set of entropy bytes, which is then converted into a new mnemonic - and subsequently, a new seed.</p> <p></p> <ul> <li>Obtain two different mnemonics (A and B) and extract their entropy bytes.</li> <li> <p>Validate the input entropies to prevent redundant or unsafe operations:</p> <ul> <li><code>A XOR B = A</code>: indicates that B consists entirely of zeros (useless - no change to the result).</li> <li><code>A XOR B = A'</code>, where <code>A'</code> is the bitwise complement of <code>A</code>: indicates that B consists entirely of ones (dangerous - produces a predictable inverse).</li> </ul> </li> <li> <p>Ensure that both mnemonics have the same length before proceeding.</p> </li> <li>Perform the XOR operation between entropy bytes from <code>A</code> and <code>B</code>.</li> <li>Validate the resulting entropy <code>C</code> (same checks as above).</li> <li>Convert the valid entropy bytes <code>C</code> into a new mnemonic <code>C</code>.</li> <li>Optionally, the user may apply a password to derive a new master seed.</li> </ul>"},{"location":"getting-started/features/mnemonic-xor/#split-and-recover-parts-or-shares","title":"Split and Recover Parts (or \"shares\")","text":"<p>A mnemonic can be split into two separate parts (or \"shares\") using the XOR operation. Each share by itself reveals nothing about the original secret. The original mnemonic can only be reconstructed when both shares are combined.</p>"},{"location":"getting-started/features/mnemonic-xor/#core-principle","title":"Core Principle","text":"<p>This method relies on a fundamental property of XOR:</p> <p>If <code>A XOR B = C</code>, then <code>B XOR C = A</code>.</p> <ul> <li>A: The original mnemonic (the secret to protect)</li> <li>B: A newly generated random mnemonic (Share 1)</li> <li>C: The mnemonic produced by the XOR operation (Share 2)</li> </ul>"},{"location":"getting-started/features/mnemonic-xor/#step-by-step-guide-to-splitting-your-mnemonic","title":"Step-by-Step Guide to Splitting Your Mnemonic","text":""},{"location":"getting-started/features/mnemonic-xor/#phase-1-splitting-process","title":"Phase 1: Splitting Process","text":""},{"location":"getting-started/features/mnemonic-xor/#generate-a-random-share-mnemonic-b","title":"Generate a Random Share (Mnemonic B)","text":"<ol> <li>Generate a new random mnemonic using dice rolls or an image.</li> <li>Important: This mnemonic must have the same number of words (12 or 24) as your original mnemonic <code>A</code>.</li> </ol>"},{"location":"getting-started/features/mnemonic-xor/#back-up-mnemonic-b","title":"Back Up Mnemonic B","text":"<ul> <li>Use a reliable and secure method to back up mnemonic <code>B</code>.</li> </ul>"},{"location":"getting-started/features/mnemonic-xor/#perform-the-xor-operation","title":"Perform the XOR Operation","text":"<ol> <li>Load mnemonic <code>A</code>.</li> <li>Navigate to Wallet -&gt; Mnemonic XOR.</li> <li>Load mnemonic <code>B</code> to be XORed with <code>A</code>.</li> <li>The resulting entropy from <code>A XOR B</code> will be used to generate the second share - mnemonic <code>C</code>.</li> </ol>"},{"location":"getting-started/features/mnemonic-xor/#back-up-mnemonic-c","title":"Back Up Mnemonic C","text":"<ul> <li>Go to Backup and securely store mnemonic <code>C</code> using your preferred backup method.</li> </ul>"},{"location":"getting-started/features/mnemonic-xor/#phase-2-verification-finalization","title":"Phase 2: Verification &amp; Finalization","text":"<p>Don't trust, verify!</p> <ol> <li>Retrieve your backups of mnemonics <code>B</code> and <code>C</code>.</li> <li>Load one of them and XOR it with the other.</li> <li>Confirm that the resulting mnemonic matches the original mnemonic <code>A</code>.</li> </ol> <p>\u26a0\ufe0f Only after successful verification should you securely destroy the original mnemonic <code>A</code>.</p>"},{"location":"getting-started/features/mnemonic-xor/#important-notes","title":"Important Notes","text":"<ul> <li>Keep shares separate: Store mnemonics <code>B</code> and <code>C</code> in different secure locations.</li> <li>Both shares required: Neither share alone reveals any information about the original mnemonic.</li> <li>Always verify!: Test the recovery process before destroying the original.</li> <li>Matching word count: All three mnemonics (<code>A</code>, <code>B</code>, and <code>C</code>) must have the same number of words.</li> </ul>"},{"location":"getting-started/features/sd-card-update/","title":"SD Card Updates","text":""},{"location":"getting-started/features/sd-card-update/#upgrade-via-microsd-card","title":"Upgrade via microSD card","text":"<p>Once you've installed Krux firmware on your device via USB, you can either continue updating the device via USB or you can perform upgrades via microSD card to keep the device airgapped.</p> <p> </p> <p>To perform an upgrade, simply copy the official release <code>firmware.bin</code> and <code>firmware.bin.sig</code> files to the root of a FAT32 MBR formatted microSD card, insert the card into your device, and reboot the device. If it detects the new firmware file and is able to verify the signature, you will be prompted to install it. Only official releases are signed.</p> <p>Once installation is complete, you will be prompted to remove firmware files from the SD Card, if you do not remove it, upon reboot you will be prompted to install it again.</p> <p>We cannot guarantee that a microSD card is compatible and will work in your device; you'll need to test it on the device to be sure, read the Troubleshooting for more info.</p>"},{"location":"getting-started/features/tamper-detection/","title":"Tamper Detection Mechanism (Experimental)","text":"<p>Krux's tamper detection tool combines cryptographic hashes, a Tamper Check Code (TC Code), and camera-generated entropy to create a tamper indicator that is unique to each device, represented by a memorable image and two sets of two words.</p> <p>Before we get into details, let's start with some limitations and necessary prerequisites to allow the feature to work.</p>"},{"location":"getting-started/features/tamper-detection/#krux-security-model-good-practices-and-limitations","title":"Krux Security Model - Good Practices and Limitations","text":"<p>To secure your Krux device, always verify firmware authenticity before installation, particularly when flashing via USB.</p>"},{"location":"getting-started/features/tamper-detection/#firmware-verification-methods","title":"Firmware Verification Methods","text":"<ul> <li> <p>Using OpenSSL Command-Line Tool: Follow from pre-built official release instructions to verify the firmware's signature manually. This method provides a high level of assurance but requires familiarity with command-line operations.</p> </li> <li> <p>Using Krux-Installer: Our Krux-Installer GUI can facilitate this process by downloading our firmware from Github and verifying its signature. It also guides you through manual verification if desired. Just don't forget to verify the integrity of the Krux-Installer as well.</p> </li> </ul>"},{"location":"getting-started/features/tamper-detection/#recommendations","title":"Recommendations","text":"<ul> <li> <p>Build from Source: Consider building the firmware from source code and verifying its reproducibility for maximum assurance.</p> </li> <li> <p>Use SD Card for Updates: After the initial flash through USB, perform subsequent updates via the SD card. This keeps your device air-gapped and allows the existing firmware to verify the new one before installation.</p> </li> </ul> <p>Note: The effectiveness of TC Flash Hash tamper detection feature relies on running legitimate, uncompromised firmware and safely protecting your TC Code.</p>"},{"location":"getting-started/features/tamper-detection/#setting-up-tamper-detection","title":"Setting Up Tamper Detection","text":"<p>To help ensure the integrity of your device\u2019s firmware, you can set up tamper detection tools, called Tamper Check (TC) Flash Hash and a Tamper Check (TC) Code. The TC Code must be at least six characters long, and for best security, should include a mix of letters, numbers, and special characters. You can create or change your TC Code by going to Settings -&gt; Security -&gt; Tamper Check Code.</p> <p>Ensure that your TC Code remains confidential and challenging to guess, as its security directly influences the effectiveness of your tamper detection.</p> <p>Once configured, your TC Code will be required to run TC Flash Hash. You can run TC Flash Hash at any time by navigating to Tools -&gt; Flash Tools -&gt; TC Flash Hash. Alternatively, enable automatic checks on every boot by selecting Settings -&gt; Security -&gt; TC Flash Hash at Boot.</p> <p>When you enable the TC Flash Hash at Boot feature, the device will require you to enter your TC Code at each startup, ensuring routine integrity checks. This also prevents device usage unless the correct code is entered.</p> <p>TC Flash Hash produces a unique visual and verbal signature (an image and two sets of words) that helps you instantly recognize unauthorized changes. See below for details on how it works and what to expect from its output.</p>"},{"location":"getting-started/features/tamper-detection/#how-krux-tamper-detection-works","title":"How Krux Tamper Detection Works","text":""},{"location":"getting-started/features/tamper-detection/#tamper-check-code-tc-code","title":"Tamper Check Code (TC Code)","text":"<p>Before being stored in the device\u2019s flash, the TC Code is hashed together with the K210 chip\u2019s unique ID and stretched using PBKDF2. This ensures the TC Code is not retrievable via a flash dump and can only be brute-forced outside the device if the attacker also has access to the device\u2019s unique ID (UID). By allowing letters, special characters, and running 100k iterations of PBKDF2, brute-forcing the TC Code from dumped data becomes more time-consuming and resource-intensive.</p>"},{"location":"getting-started/features/tamper-detection/#enhancing-tamper-detection","title":"Enhancing Tamper Detection","text":"<p>After setting the TC Code, you are prompted to fill empty flash memory blocks with random entropy from the camera. This process ensures that attackers cannot exploit unused memory space.</p>"},{"location":"getting-started/features/tamper-detection/#tamper-check-flash-hash-tc-flash-hash-a-tamper-detection-tool","title":"Tamper Check Flash Hash (TC Flash Hash) - A Tamper Detection Tool","text":"<p>The TC Flash Hash tool enables you to verify if the device's internal flash memory content has been altered. This tool generates a unique image and two sets of two tamper detection words based on a hash of your TC Code, the device's UID, and its internal flash content. The flash memory is divided into two regions:</p> <ul> <li> <p>Firmware Region: The area only filled with firmware code. It generates the memorable image and the first set of two words.</p> </li> <li> <p>User's Region: The area used to stored encrypted mnemonics, settings and TC Code. It generates the last set of two words.</p> </li> </ul> <p>Example: On the image, the red symbol and words 'debate lunar' represent the firmware region, while 'renew great' user's region.</p> <p>Any change in the flash content results in a different image and words:</p> <ul> <li> <p>Firmware Changes: Alterations in the firmware region, including the bootloader, change the image and the first set of two words.</p> </li> <li> <p>User's Data Changes: Changes in the user's region, such as new settings or stored mnemonics, change the last set of two words.</p> </li> <li> <p>TC Code Changes: Replacing the TC Code alters the image and all sets of words.</p> </li> </ul>"},{"location":"getting-started/features/tamper-detection/#filling-empty-flash-memory-blocks","title":"Filling Empty Flash Memory Blocks","text":"<p>Use this to enhance tamper detection. Krux performs a memory sweep while capturing a live feed from the camera. Whenever an empty block is found in the flash memory, it uses the data from the image to fill these empty spaces when the entropy is good enough. It estimates the image's entropy by evaluating its color variance waiting until a minimum threshold is met.</p> <p>A progress bar is shown below, when the highlighted color appears, it means that this flash memory space is not empty and Krux will move on to the next one to fill any empty spaces. When you run it a second time, nothing will change because all the memory will be filled. You will see the progress bar move quickly, showing only the highlighted color, and a still image will be displayed on the camera during the process.</p>"},{"location":"getting-started/features/tamper-detection/#ensuring-tamper-detection","title":"Ensuring Tamper Detection","text":"<p>The TC Flash Hash function securely hashes the combination of the TC Code, device's UID, and flash memory contents. The hash properties ensure that without knowing these three elements, an attacker will not be able to reproduce the TC Flash Hash results.</p>"},{"location":"getting-started/features/tamper-detection/#executing-tc-flash-hash","title":"Executing TC Flash Hash","text":"<p>After setting a TC Code user can use the TC Flash Hash feature, available in Tools -&gt; Flash Tools -&gt; TC Flash Hash.</p> <p>By navigating to Settings -&gt; Security -&gt; TC Flash Hash at Boot, users can set Krux to always require TC Flash Hash verification after device is turned on. If a wrong TC Code is typed at boot, the device will turn off. Nothing else will happen if the wrong TC Code is entered multiple times. As TC Code verification data is stored in the user's region of memory, the requirement to type at boot is disabled if the user erases user's data or wipe device. Flashing an older firmware version, prior to TC Flash Hash support, will also disable this feature.</p>"},{"location":"getting-started/features/tamper-detection/#potential-attack-scenarios-and-their-mitigation","title":"Potential Attack Scenarios and Their Mitigation","text":""},{"location":"getting-started/features/tamper-detection/#challenge-for-an-attacker","title":"Challenge for an Attacker","text":"<p>An attacker faces major challenges in replacing the firmware:</p> <ul> <li> <p>Lack of Original Flash Data: Without the exact original flash content, attackers cannot reproduce the correct hash.</p> </li> <li> <p>Sequential Hash Dependency: The hash function processes data sequentially (TC Code, device's UID, and flash memory contents), preventing the attacker from injecting or rearranging data to produce the same hash.</p> </li> <li> <p>One-Way Hash Functions: Cryptographic hash functions like SHA-256 are one-way, making it infeasible to reverse-engineer or manipulate the hash without the original inputs.</p> </li> </ul>"},{"location":"getting-started/features/tamper-detection/#why-tampered-firmware-cannot-bypass-verification","title":"Why Tampered Firmware Cannot Bypass Verification","text":"<ul> <li> <p>Cannot Reconstruct the Hash: Without the original flash data, attackers cannot generate the correct hash, even if they know the device's UID and the TC Code (after the user enters it).</p> </li> <li> <p>Hash Sensitivity: Any alteration in the flash content changes the hash output, which will be evident through a different image and words.</p> </li> <li> <p>Entropy Filling: Filling empty flash blocks with camera-generated entropy leaves no space for malicious code and any changes to these blocks will alter the hash.</p> </li> </ul>"},{"location":"getting-started/features/tamper-detection/#possible-attack-strategies-and-failures","title":"Possible Attack Strategies and Failures","text":"<ul> <li> <p>Precomputing Hashes: The attacker cannot precompute the correct hash without the TC Code, device's UID, and exact contents of the flash memory.</p> </li> <li> <p>Storing Hashes: Storing <code>hash(flash_content)</code> is ineffective because the overall hash depends on the sequential combination of TC Code, device's UID, and the flash data.</p> </li> <li> <p>Inserting Malicious Code: Attempting to insert code into empty spaces fails because after the entropy filling process, the hash verification will detect any changes.</p> </li> <li> <p>Using an SD Card to Store a Copy of Original Flash Content: An attacker could extract an exact copy of the flash contents to an SD card and subsequently install malicious firmware. This firmware could read the device's UID and the TC Code (after the user enters it), then hash the content of the SD card instead of the flash memory. Although this would make the verification process slower, it introduces a potential security risk. To mitigate this vulnerability, it is advisable to avoid performing verifications while an SD card is inserted. </p> </li> </ul>"},{"location":"getting-started/features/tamper-detection/#conclusion","title":"Conclusion","text":"<p>The TC Flash Hash tool significantly enhances security by making it infeasible for attackers to tamper with firmware without being detected. By combining TC Code hashing, filling empty memory with random entropy, and verification of the the unique image and set of words, Krux allows the detection of any tamper attempts.</p> <p>Note: The strength of this defense strategy depends on maintaining a strong, confidential TC Code, removing the SD card before running TC Flash Hash and following usual security and privacy practices.</p>"},{"location":"getting-started/features/tinyseed/","title":"Tiny Seed and other metal plates","text":""},{"location":"getting-started/features/tinyseed/#background","title":"Background","text":"<p>The examples below have been created so that you can test the workflow for scanning both 12 and 24 word mnemonics (the left plate only for a 12 word mnemonic and both plates for 24). The resulting fingerprint from an successful scan is also incldued in the image.</p>"},{"location":"getting-started/features/tinyseed/#tinyseed","title":"Tinyseed","text":""},{"location":"getting-started/features/tinyseed/#onekey-keytag","title":"OneKey KeyTag","text":""},{"location":"getting-started/features/tinyseed/#binary-grid","title":"Binary Grid","text":""},{"location":"getting-started/features/tinyseed/#size-offset-and-padding-reference","title":"Size, Offset and Padding Reference","text":"<p>The general logic for how these are processed is:</p> <ol> <li>Krux first looks for a square (works best if with a well lit square, with clean edges, on a dark background).</li> <li>The square is checked and if the ratio of length to height is within a defined range for the given seed type, the square is further processed (uses the aspect_high and aspect_low variables).</li> <li>An X and Y offset are applied to work out the corner of the seed grid within the seed plate. Some devices like the Maix Amigo use a mirrored coordinate system and some seed types will have a slightly different layout on the front and back of the plate (uses the x_offset and y_offset variables, p0 for the front face and p1 for the reverse face).</li> <li>The location of each cell within the 12x12 grid is calculated (uses the xpad and ypad variables).</li> <li>Krux uses the grid created in step 4. to evaluate which cells are marked and which are blank, once a seed with a valid checksum is detected, the user can then confirm the dots.</li> </ol> <p>If you have a different type of grid that you want to use, you will need to edit the offsets and padding numbers in <code>tiny_seed.py</code> (all of the sizes are scaled based on the size of the square detected in step 1.).</p> <p>You can match the pre-sets for supported key-types to the physical dimensions of the tag as shown below (offset numbers are in 1/10th of a millimeter).</p> <p></p>"},{"location":"getting-started/features/tools/","title":"Tools","text":"<p>Here are some useful tools that are available as soon as Krux starts! These are offered as a complement to managing your device and wallets.</p> <p> </p>"},{"location":"getting-started/features/tools/#datum-tool","title":"Datum Tool","text":"<p>Datum Tool is an advanced, educational feature that treats all input as a simple datum. It provides flexibility for working with QR codes, manually entered text, and files from SD</p> <p> </p> <p>Once datum has been loaded, it offers meta information about the contents and ability to View Datum - whether text or binary. It also offers a menu to Convert Datum, Export to QR, and Export to SD.</p> <p> </p> <p>The Convert Datum menu allows access to common encodings for conversion between bytes and string data. It also offers access to Encrypt contents with full-control to make specific encryption choices. For more info, see encryption.</p>"},{"location":"getting-started/features/tools/#device-tests","title":"Device Tests","text":"<p>Run these quick checks to ensure your Krux device is functioning properly.</p>"},{"location":"getting-started/features/tools/#check-sd-card","title":"Check SD Card","text":"<p>Verify whether your device detects and reads the SD card, and browse its contents. Files can be deleted individually. If there are more files than can fit on a single screen, swipe up  or down  to navigate between the screens - if your device has a touchscreen.</p> <p>The SD card is optional, but can be used for firmware upgrades and for storing settings, encrypted mnemonics, XPUBs, QR codes, and CNC/files. It is also useful for saving and loading PSBTs, wallet output descriptors, and messages.</p>"},{"location":"getting-started/features/tools/#print-test-qr","title":"Print Test QR","text":"<p>Quickly print a test QR code to check and optimize your printer setup.</p>"},{"location":"getting-started/features/tools/#test-suite","title":"Test Suite","text":"<p>A suite of automated tests to verify important features on your device.</p>"},{"location":"getting-started/features/tools/#touchscreen-maix-amigo-yahboom-wondermv-and-tzt-only","title":"Touchscreen (Maix Amigo, Yahboom, WonderMV and TZT only)","text":"<p>Confirm that touch input is accurately detected across the entire display surface.</p>"},{"location":"getting-started/features/tools/#descriptor-addresses-wallet-sans-key","title":"Descriptor Addresses (Wallet Sans Key)","text":"<p>Verify if an address or list of addresses belong to a wallet without needing to load private keys. Simply load a trusted wallet descriptor from a QR code or SD card.</p>"},{"location":"getting-started/features/tools/#flash-tools","title":"Flash Tools","text":"<p>Tools to inspect the content of device's flash memory and clear user's area.</p>"},{"location":"getting-started/features/tools/#flash-map","title":"Flash Map","text":"<p>Flash map indicates which memory blocks (4086 Bytes each) are empty. Memory is separated in two regions: Firmware and User's Data. White or colored blocks contain data, while grey blocks are empty.</p> <p>This is an interesting tool to visualize the effects of filling the memory with ramdom entropy, what is done during the setup of a new <code>TC Code</code>, used with <code>TC Flash Hash</code> tool, described below.</p>"},{"location":"getting-started/features/tools/#tc-flash-hash","title":"TC Flash Hash","text":"<p>Tamper Check (TC) Flash Hash is a tamper detection mechanism that enables you to verify if the flash memory content has been altered. To use it first, need to create a Tamper Check (TC) Code on Settings -&gt; Security -&gt; Tamper Check Code. TC Flash Hash will hash TC Code, K210 chip's unique ID and the content of the whole internal flash creating a tamper indicator that is unique to each device, represented by a memorable image and two sets of two words.</p> <p>More information on Tamper Detection page.</p>"},{"location":"getting-started/features/tools/#erase-users-data","title":"Erase User's Data","text":"<p>This option permanently removes all stored encrypted mnemonics, settings and <code>TC Code</code> from the device's internal flash memory. It ensures that the data is irrecoverable, making it an adequate measure to take if any important mnemonics were stored with a weak encryption key.</p>"},{"location":"getting-started/features/tools/#remove-mnemonic","title":"Remove Mnemonic","text":"<p>This option allows you to remove any stored encrypted mnemonic from the device's internal memory or an SD card. For more information, see encryption.</p> <p>When mnemonics are removed from the device's flash memory, Krux will no longer be able to access them. However, as with most operating systems, the data may still be recoverable using specialized tools. If you stored any important keys with a weak encryption key, it is recommended to use the Flash Tools -&gt; Erase User's Data feature above to ensure that the data is irrecoverable.</p> <p>Note: When mnemonics are removed from an SD card, Krux will overwrite the region where the encrypted mnemonic was stored with empty data. This makes it more secure to delete mnemonics from SD cards using Krux rather than a PC or another device. However, Krux does not have a \"Wipe\" feature for SD cards; you can find this feature in third-party applications.</p>"},{"location":"getting-started/features/encryption/encryption/","title":"Encryption Introduction","text":"<p>Encryption is an advanced feature for securely hiding a secret. However, if used incorrectly, the secret may become unrecoverable without a separate plain-text backup. Before using it, carefully review this document and pay close attention to all warnings.</p>"},{"location":"getting-started/features/encryption/encryption/#in-general","title":"In General","text":"<p>In Settings -&gt; Encryption Settings, you can adjust PBKDF2 Iterations and Encryption Mode before loading a wallet. When encrypting, Krux applies these preferences to optimize for the specific secret being secured, producing an encrypted KEF envelope that can be exported as a QR or saved to SD.</p> <p>During encryption, users may be prompted to override their preferences or select a specific version. Most importantly: the encryption key MUST be strong. If a KEF envelope is created with a weak key and shared or exposed, it should be assumed to offer NO protection, and the secret will be leaked.</p> <p> </p> <p>When Krux detects data resembling a KEF-encrypted envelope, it prompts the user to \"Decrypt?\", showing the KEF version, envelope ID (or label), and the PBKDF2 iteration count used during creation. To decrypt, the same key (typed or scanned) must be provided. Once unlocked, Krux uses the plaintext within context. If decryption is declined, the raw envelope is used instead\u2014usually resulting in an error, since KEF data is meaningless without decryption.</p> <p>KEF envelopes are deliberately opaque, providing no information about their contents or the key needed for decryption. It is the user\u2019s responsibility to track this\u2014by noting what each envelope contains, how to decrypt it, and assigning an ID at encryption to help recall its contents and locate the correct key. During encryption, Krux suggests an ID that the user can modify. For mnemonics, the default ID is the wallet fingerprint without a passphrase; for wallet output descriptors, it defaults to the wallet\u2019s generic policy.</p> <p>Within the Tools menu, users may experiment with Datum tool for encrypting small to mid-sized contents (less than 50K bytes) and for decrypting KEF envelopes.</p>"},{"location":"getting-started/features/encryption/encryption/#regarding-bip39-mnemonics","title":"Regarding BIP39 Mnemonics","text":"<p>There are several ways to add security layers to a wallet\u2019s private key. The most common is adding a BIP39 passphrase to the mnemonic. Encrypting a BIP39 mnemonic serves a similar purpose, but differs in a key way: with BIP39 passphrases, entering the wrong passphrase loads a different wallet, while with Krux\u2019s encrypted mnemonics, a wrong key simply returns an error. Depending on the use case, this behavior may be preferable. Krux\u2019s implementation also stores a mnemonic ID alongside the data for convenience. Encrypted mnemonics can be combined with a BIP39 passphrase for added security, and the same mnemonic can be encrypted with multiple different keys.</p>"},{"location":"getting-started/features/encryption/encryption/#aes-modes-of-operation","title":"AES Modes-of-Operation","text":"<p>Krux uses standard AES encryption with modes-of-operation: ECB, CBC, CTR and GCM. The user may set their preference within <code>Settings, Encryption Settings, Encryption Mode</code>. Krux uses GCM as the default mode-of-operation, but you may have valid reasons for making your own choice, ie:</p> <ul> <li>maybe you want compatibility with other software or devices you use,</li> <li>maybe you want the smallest QR possible for high-entropy secrets like mnemonics or passhprases,</li> <li>etc.</li> </ul>"},{"location":"getting-started/features/encryption/encryption/#aes-ecb","title":"AES-ECB","text":"<p>ECB (Electronic Codebook) is a simpler method where data blocks are encrypted individually. This mode is faster and simpler to encrypt, resulting in QR codes with lower density that are easier to transcribe. It is generally considered less secure than others because it does not provide data chaining, meaning identical plaintext blocks would produce identical ciphertext blocks, making it vulnerable to pattern analysis. However, in Krux's implementation, encrypting plaintext via ECB which contains duplicate blocks has been intentionally disabled.</p>"},{"location":"getting-started/features/encryption/encryption/#aes-cbc","title":"AES-CBC","text":"<p>CBC (Cipher-block Chaining) is considered more secure than ECB. In the first data block, an initialization vector (IV) is used to add random data to the encryption. The encryption of subsequent blocks depends on the data from previous blocks, characterizing chaining. Tradeoffs are that encryption/decryption must be done in series and when encrypting, a camera snapshot will be needed to generate the IV, so it's a slower process. The IV will always stored together with encrypted data, making encrypted QR codes denser and harder to transcribe. This mode is often available on other microcontroller devices.</p>"},{"location":"getting-started/features/encryption/encryption/#aes-ctr","title":"AES-CTR","text":"<p>CTR (Counter Mode) like CBC is more secure than ECB, because of the use of an Initialization Vector, and also most efficient as a stream cipher, capable of encrypting and decrypting in parallel. This mode is often available on other microcontroller devices.</p>"},{"location":"getting-started/features/encryption/encryption/#aes-gcm","title":"AES-GCM","text":"<p>GCM (Galois Counter-Mode). Similar to CBC and CTR, the cipher is initialized with a nonce from a camera snapshot. Like CTR, it is a paralellizable stream cipher, and also adds Galois Field authentication inherently. Capable of optimized performance, with built-in authentication and ease of implementation, this mode is the Krux default unless the user has selected otherwise.</p>"},{"location":"getting-started/features/encryption/encryption/#initialization-vector","title":"Initialization Vector","text":"<p>Modes ECB, CBC, and GCM use an Initialization Vector (IV), where IV is better termed <code>nonce</code> for GCM. The IV will be generated from a snapshot taken with the camera. It is a fixed-size input value used to initialize the cipher, adding randomness to the encryption, and ensuring that data encrypted with the same key will produce different ciphertexts each time. The IV, or nonce, is not secret and will be transmitted along with the ciphertext. However, like any nonce, it should not be reused to maintain security.</p>"},{"location":"getting-started/features/encryption/encryption/#key-stretching-pbkdf2-iterations","title":"Key Stretching (PBKDF2 Iterations)","text":"<p>When you enter the encryption key, it is not directly used to encrypt your data. In order to protect against brute force attacks, the user supplied key is derived multiple times - stretched to 256 bits via <code>pbkdf2_hmac_sha256</code>. PBKDF2 (Password-Based Key Derivation Function) Iterations refer to the number of derivations that will be performed over your key - as the <code>password</code> - <code>salted</code> with an ID, prior to encrypting/decrypting your secret. Users may set a preferred <code>PBKDF2 Iterations</code> value in <code>Encryption Settings</code>, then Krux will propose a slightly different value - within a 10% delta, whenever encrypting.</p>"},{"location":"getting-started/features/encryption/encryption/#kef-encryption-format","title":"KEF Encryption Format","text":"<p>When Krux encrypts a secret, the result is a <code>KEF Envelope</code> - which is a series of bytes. Each envelope is constructed similarly, containing fixed-length and variable-length fields representing: a custom <code>ID</code> for the envelope, a <code>Version</code>, number of PBKDF2 <code>Iterations</code>, and a <code>Cipher PayLoad</code>, so that any devices or software supporting KEF may recognize the envelope and know how to decrypt it - given the correct <code>key</code>. These fields, within each KEF envelope are:</p> ID length (1) ID (2) Version (3) Key Derivations (4) Cipher PayLoad (5, 6, and 7) 1 Byte Variable 1 Byte 3 Bytes Variable <ul> <li>Visible data (1 to 4):<ul> <li>(1) Mnemonic ID length (1 Byte).</li> <li>(2) Mnemonic ID (variable length): Custom <code>ID</code> (wallet fingerprint for mnemonics).</li> <li>(3) Version (1 Byte): Version of encryption method; currently twelve are available -- details later.</li> <li>(4) key derivation Iterations (3 bytes): Number of PBKDF2 key derivations. if &lt;= 10,000, multiplied by 10,000.</li> </ul> </li> <li>Cipher PayLoad (5, 6, and 7):<ul> <li>(5) IV (12 or 16 bytes, optional): Initialization Vector for modes: CBC or CTR, and nonce for GCM.</li> <li>(6) Encrypted Ciphertext.</li> <li>(7) Authentication/validation data (3, 4, or 16 bytes).</li> </ul> </li> </ul>"},{"location":"getting-started/features/encryption/encryption/#version-details","title":"Version Details","text":"<p>While all KEF envelopes share the above format, each version differs - offering choices to the user, as trade-offs that may better fit a particular use-case. For technical details, see: KEF specifications</p> Version Name Mode IV Compressed Intended Use Case 0 AES-ECB v1 ECB -- -- Legacy (&lt;= v25.03.0): mnemonic entropy 1 AES-CBC v1 CBC 16 -- Legacy (&lt;= v25.03.0): mnemonic entropy 5 AES-ECB ECB -- -- Smallest QR; mnemonic, passphrase 6 AES-ECB +p ECB -- -- General Mid-sized 7 AES-ECB +c ECB -- Yes Large; repetitive text 10 AES-CBC CBC 16 -- Small, high-entropy 11 AES-CBC +p CBC 16 -- General mid-sized 12 AES-CBC +c CBC 16 Yes General large 15 AES-CTR CTR 12 -- General mid-sized 16 AES-CTR +c CTR 12 Yes General large 20 AES-GCM GCM 12 -- Default; General mid-sized 21 AES-GCM +c GCM 12 Yes Default; General large"},{"location":"getting-started/features/encryption/encryption/#considerations","title":"Considerations","text":"<p>Storage of encrypted secrets on the device or SD cards are meant for convenience only and should not be considered a long-term form of backup. Always make a physical backup of your keys that is independent from electronic devices and test recovering your wallet from this backup before you send funds to it. Flash storage can degrade over time and may be subject to permanent damage, resulting in the loss of stored information.</p> <p>Remember that any encrypted secret is protected by the key you defined to encrypt it. If the defined key is weak, your encrypted mnemonic and other secrets will not be protected. If you have stored sensitive secrets in the device's internal flash memory using a weak key, the best way to undo this is to erase user's data.</p>"},{"location":"getting-started/features/encryption/kef-specifications/","title":"KEF Encryption Format - Technical Specification","text":"<p>...<code>The K stands for \"KEF\"</code> -anon</p>"},{"location":"getting-started/features/encryption/kef-specifications/#motivation","title":"Motivation","text":"<p>In the autumn of 2023, during the lead-up to krux release 23.09.0, contributors proposed a method of encrypting bip39 mnemonics that could be stored in SPI-flash, on sdcard, and/or exported to QR. Regarding the encrypted-mnemonic QR format: the layout proposed was interesting as an extensible, lite-weight, self-describing envelope that has been appreciated by users ever since.</p> <p>...<code>\"Wen passphrases, output descriptors, PSBTs, and notes?\"</code> -plebs</p> <p>This specification, and its accompanying implementation and test-suite are the result of months of exploration into improvements meant to better define, test, and extend the original encryption format that we'll refer to as KEF. It proposes ten new versions, extending its usefulness to more than mnemonics, targeting variable-length strings up to moderately sized PSBTs, flexibility to choose among four AES modes of operation, with-or-without compression, and versions optimized to result in a smaller envelope.</p> <p>Above all, this specification aims to be supported by as many projects as would consider adopting it, so that users are not \"locked\" into a particular project when recovering their secrets. Corrections and refinement to, and scrutiny of this specification are appreciated. Proposals for more <code>versions</code> are welcome, provided they offer \"value\" to the user and fit within the scope of this system. Once released, because it cannot be known how many KEF envelopes may exist in-the-wild, changes to any particular version must remain backwards compatible for decryption. Adopting implementations are free to support any KEF versions they wish to support, for decryption-only or for both encryption and decryption - with the expectation that claims-of-support made are clear and precise about what is supported.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#overview","title":"Overview","text":"<p>This system encrypts arbitrary plaintext into a versioned, self-describing, KEF envelope which includes:</p> <ul> <li>custom identity/label <code>len_id</code> and <code>id</code></li> <li>version <code>v</code></li> <li>pbkdf2-hmac iterations <code>i</code></li> <li>and cipher-payload <code>cpl</code></li> </ul> <p>where cipher-payload <code>cpl</code> consists of:</p> <ul> <li>Initialization-Vector/Nonce (if applicable) <code>IV</code></li> <li>ciphertext</li> <li>and authentication/validation data <code>auth</code></li> </ul> <p>KEF versions offer combinations of different modes-of-operation, authentication strategies, padding strategies, and compression, all selected via a numeric version code (0 - 21).</p> <ul> <li>Available version codes are: 0, 1, 5, 6, 7, 10, 11, 12, 15, 16, 20, 21. Not all integers in the range are assigned, and implementations may disable versions or modes.</li> </ul> <p>Currently, all versions use AES and derive the 256-bit encryption key <code>k</code> as: <pre><code>k = pbkdf2_hmac_sha256(K, id, i)\n</code></pre></p> <p>where:</p> <ul> <li><code>K</code> = user-provided password/key material (bytes; if str: non-normalized encode as utf-8)</li> <li><code>id</code> = salt (variable-length, prepended to envelope; bytes: if str: non-normalized encode as utf-8)</li> <li><code>i</code> = iteration count (3 bytes, big-endian)</li> </ul> <p>The stored iteration field <code>i</code> MUST be \u2265 1. The effective PBKDF2 iteration count is <code>i</code> if <code>i &gt; 10,000</code>, otherwise <code>i * 10,000</code>.</p> <p>Compression (when enabled) uses zlib.compress(wbits=-10) or raw deflate(micropython).</p> <p>Authentication has three forms:</p> <ul> <li>When the mode has built-in authentication, like GCM: <code>auth</code> is a truncated auth tag</li> <li>When the mode does not have built-in authentication, <code>auth</code> is a truncated sha256 digest whose pre-image is of two forms:<ul> <li>if <code>auth</code> will be encrypted with plaintext, hidden, it is <code>sha256(plaintext)</code></li> <li>if <code>auth</code> will be appended to ciphertext, exposed, it is <code>sha256(version || IV || plaintext || derived-k)</code></li> </ul> </li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#generalizations-regarding-implementation","title":"Generalizations Regarding Implementation","text":"<p>It is expected that any implementation can decrypt a KEF envelope that was created by itself on the same device. Implementations are asked to make their \"best-effort\" to be capable of decrypting KEF envelopes for versions they support which were created by other implementations or on other devices - but this will not always be possible. Decrypting large KEF envelopes on severely constrained devices, or ones created with flawed implementations is unrealistic. Therefore, in such cases it is the responsibility of the user to find an implementation and device capable of decrypting their KEF envelope, or to have a non-KEF form of recovery.</p> <ul> <li> <p>Be strict while encrypting. Be tolerant - and non-specific about errors, when decrypting.</p> </li> <li> <p>At its base, a KEF envelope is a format of bytes - so are all of its inputs. Remember this when converting strings gathered for the <code>key</code> and <code>id</code>. Consider being strict about offering a reasonably minimal set of characters, common and available on other devices and/or international keyboards when encrypting - then encode unicode codepoints (if not ascii) directly to their utf-8 representations without normalization. For decryption, more characters could be offered when gathering the <code>key</code>, and multiple normalization strategies may be tried, so that secrets may be recovered. Consider some capability of displaying both <code>key</code> and <code>id</code> as bytes, and gathering the <code>key</code> as bytes either directly or via hex/base64 conversion if necessary, to enable recovery. Do NOT assume that a user originally used a particular implementation to encrypt a KEF envelope.</p> </li> <li> <p>On the importance of a STRONG user-supplied <code>key</code> This cannot be stressed enough to each user of KEF. While KEF allows for key-stretching via <code>id</code> and <code>iterations</code>, and offers modes that require a random <code>IV</code> / Nonce, KEF offers no expectation of security for a weak user-supplied <code>key</code>. Consider making this point clear to users before encrypting and/or offer an indication of <code>key</code> strength once gathered. If a KEF envelope has been created with a \"weak\" <code>key</code> and stored accessible to others, user should assume that their secret has been leaked. Consider encouraging users to make sane choices about the characters they use in their <code>key</code>, aware that non-ascii characters offered by one implementation may not be easy to enter on another, or that a recognizable glyph may not exist on other devices for them to verify their <code>key</code> when decrypting.</p> </li> <li> <p>On security Not all KEF <code>versions</code> offer the same security guarantees, so implementors MUST take care to protect against \"unsafe\" usage. As already mentioned: be strict and fail to encrypt when \"unsafe\"; be tolerant and vague while decrypting. Support for decrypt-only on a particular version is perfectly valid should an implementation choose to \"nudge\" users towards a more-secure version where it supports full encrypt/decrypt functionality.</p> <ul> <li> <p>On mode ECB: Repeated blocks would leak patterns within ciphertext. Therefore, be strict - refuse to encrypt using mode ECB whenever duplicate blocks are detected. Consider a compressed version which may resolve this.</p> </li> <li> <p>On block modes with NUL padding Problems to unpad can arise decrypting where valid NUL bytes are confused with removable padding.</p> <ul> <li>If <code>auth</code> is appended to plaintext before padding AND the <code>auth</code> bytes end in 0x00: be strict - refuse to encrypt. Consider a version with safe padding.</li> <li>If <code>auth</code> is appended to ciphertext after padding/encryption AND the <code>plaintext</code> bytes end in 0x00: be strict - refuse to encrypt. Consider a version with safe padding.</li> <li>Do not assume that other implementations adhere to the above. Be tolerant and make reasonable efforts to successfully recover secrets when decrypting. Offering a warning to users AFTER successful decryption in this case may be appropriate.</li> </ul> </li> </ul> </li> <li> <p>On modes that require IV or Nonce Take precautions to ensure that this value is random and not reused. ie: Natural entropy captured from camera sensor (user validated and/or analyzed to ensure sensor is working / high entropy).</p> </li> <li> <p>On common <code>bytes</code> encodings Outside the strict scope that KEF envelopes are a format of bytes but related to this topic: implementations may be presented with encoded strings that are likely to represent bytes. For instance: base64, base43 (from electrum), base32, or hex might be representations of a KEF envelope that was previously encoded for transport. As you continue reading, it will become clear that with any bytestring, one may recognize a KEF envelope by:</p> <ol> <li>reading the first byte as an integer <code>len_id</code>,</li> <li>jumping that many bytes, over the <code>id</code>, to read the next byte as an integer <code>version</code>,</li> <li>if that version represents a known and supported KEF version, then the rest of the envelope may be parsed via that version's KEF rules.</li> <li>if parsing succeeds without errors, it is likely to be a KEF envelope and a decryption user-interface should be offered to the user. While the user likely knows, the process instance of a KEF implementation will learn definitively, only AFTER a successful decryption, that a bytestring was indeed a KEF envelope. If at any point along this process, an implementation finds that <code>version</code> is unknown/disabled, or if parsing fails, the expected action is NOT TO RAISE SPECIFIC ERRORS regarding this inspection. Rather, the appropriate action is to assume it was not a KEF envelope and to treat the data under another context: ie: \"Unknown\". Similarly, as mentioned above, being vague about errors during decryption implies that \"Failed!\" may be a sufficient response for any error, instead of leaking to a potential attacker specific details about the failure.</li> </ol> </li> <li> <p>On Iterations Consider that users may want to decrypt KEF envelopes on various resource-constrained devices. There is a minimum 10,000 iterations imposed in any KEF envelope (a value of 1 would be 10,000 pbkdf2_hmac iterations), and the maximum could be as high as 100,000,000 (a value of 10,000), but depending on the device used, 500,000 might be too high. Also, since the user-supplied <code>key</code> is stretched by this value, consider offering a range to users - then adding a small <code>delta</code> as extra bits of entropy to derive different AES-256 keys that would otherwise be the same in the event the user re-uses the same <code>key</code>, <code>id</code> and <code>iterations</code> when creating many KEF envelopes.</p> </li> <li> <p>On truncated Authentication At first glance it may be concerning that <code>auth</code> bytes for many versions have been truncated and are trivially \"weak\". Note that KEF's use-case for authentication is to validate that the user has correctly entered their decryption <code>key</code>. In the worse case, \"false-authenticated\" success will occur at a rate of 1:16M (or 1:4B for others) if using an incorrect decryption <code>key</code>; similar if an attacker has modified the KEF envelope. In these \"false-authenticated\" success cases, data will result from decryption, but that data will NOT be the original secret or plaintext; it will be of no value.</p> </li> <li> <p>On compressed versions KEF is strict about compressing via \"raw headerless deflate()\" with a \"wbits\" window of 10 bits (1024B) so that other implementations on restricted hardware are capable to decompress and recover any KEF envelope.  However, implementations may choose to use a higher wbits window for decompression.</p> </li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#common-structure-of-a-kef-envelope","title":"Common Structure of a KEF Envelope","text":"<p>All KEF versions' encrypted outputs follow this layout: <pre><code>len_id + id + v + i + cpl\n</code></pre></p> Field Size Description <code>len_id</code> 1 byte Length of <code>id</code> (0 - 252) <code>id</code> <code>len_id</code> bytes Salt for PBKDF2 <code>v</code> 1 byte Version number <code>i</code> 3 bytes Iteration count (big-endian; if &lt;= 10,000: *= 10,000) <code>cpl</code> Variable Cipher PayLoad (IV + ciphertext + auth) <p>The Cipher PayLoad <code>cpl</code> structure varies by version. </p>"},{"location":"getting-started/features/encryption/kef-specifications/#versions-details","title":"Versions - Details","text":"<p>Details for currently-available versions of KEF follow. The top half of each section is pre-formatted <code>self-doc</code> text, built from the reference implementation's test-suite (using KEF <code>VERSION</code> constants as KEF's rule-set). The bottom half of each section with rich-formatted text was initially LLM-generated, prompted with the <code>self-doc</code> text, then curated and edited by hand.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#v0-aes-ecb-v1","title":"v0: \"AES-ECB v1\"","text":"<pre><code>[AES-ECB v1] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =0\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: e.encrypt(P + auth + pad)\ne: AES(k, ECB)\nauth: sha256(P)[:16]\npad: NUL\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: ECB</li> <li>IV: None</li> <li>Padding: NUL bytes to block boundary</li> <li>Authentication: First 16 bytes of <code>SHA256(plaintext)</code>, hidden</li> <li>cpl layout: <code>[ciphertext]</code> (auth embedded before padding/encryption)</li> <li>Use Case: LEGACY: consider using version 5; encryption of 16 or 32 BIP39 entropy bytes</li> <li>Security Note: When encrypting: fail \"unsafe\" if duplicate plaintext blocks, fail \"unsafe\" if auth ends 0x00</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v1-aes-cbc-v1","title":"v1: \"AES-CBC v1\"","text":"<pre><code>[AES-CBC v1] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =1\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(P + auth + pad)\niv: 16b\ne: AES(k, CBC, iv)\nauth: sha256(P)[:16]\npad: NUL\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: CBC</li> <li>IV: 16 bytes</li> <li>Padding: NUL bytes to block boundary</li> <li>Authentication: First 16 bytes of <code>SHA256(plaintext)</code>, hidden</li> <li>cpl layout: <code>[iv (16)] + [ciphertext]</code> (auth embedded before padding/encryption)</li> <li>Use Case: LEGACY: consider using version 10; encryption of 16 or 32 BIP39 entropy bytes</li> <li>Security Note: When encrypting: do not re-use IV, fail \"unsafe\" if auth ends 0x00</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v5-aes-ecb","title":"v5: \"AES-ECB\"","text":"<pre><code>[AES-ECB] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =5\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: e.encrypt(P + pad) + auth\ne: AES(k, ECB)\npad: NUL\nauth: sha256(v + P + k)[:3]\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: ECB</li> <li>IV: None</li> <li>Padding: NUL bytes to block boundary</li> <li>Authentication: First 3 bytes of <code>SHA256(version_byte + plaintext + derived_key)</code>, exposed</li> <li>cpl layout: <code>[ciphertext] + [auth (3)]</code></li> <li>Use Case: smallest KEF envelope for high-entropy secrets (BIP39 entropy, passphrase, cryptographic keys)</li> <li>Security Note: When encrypting: fail \"unsafe\" if duplicate plaintext blocks, fail \"unsafe\" if plaintext ends 0x00</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v6-aes-ecb-p","title":"v6: \"AES-ECB +p\"","text":"<pre><code>[AES-ECB +p] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =6\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: e.encrypt(P + auth + pad)\ne: AES(k, ECB)\nauth: sha256(P)[:4]\npad: PKCS7\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: ECB</li> <li>IV: None</li> <li>Padding: PKCS7 to block boundary</li> <li>Authentication: First 4 bytes of <code>SHA256(plaintext)</code>, hidden</li> <li>cpl layout: <code>[ciphertext]</code> (auth embedded before padding/encryption)</li> <li>Use Case: Mid-sized variable length plaintext</li> <li>Security Note: When encrypting: fail \"unsafe\" if duplicate plaintext blocks</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v7-aes-ecb-c","title":"v7: \"AES-ECB +c\"","text":"<pre><code>[AES-ECB +c] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =7\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: e.encrypt(zlib(P, wbits=-10) + auth + pad)\ne: AES(k, ECB)\nauth: sha256(zlib(P, wbits=-10))[:4]\npad: PKCS7\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: ECB</li> <li>IV: None</li> <li>Compression: <code>zlib.compress(P, wbits=-10)</code>, - raw deflate</li> <li>Padding: PKCS7 to block boundary</li> <li>Authentication: First 4 bytes of <code>SHA256(plaintext)</code>, hidden</li> <li>cpl layout: <code>[ciphertext]</code> (auth embedded after compression, before padding/encryption)</li> <li>Use Case: Mid-sized variable length plaintext</li> <li>Security Note: like others, when encrypting: fail \"unsafe\" if duplicate blocks - unlikely with compression </li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v10-aes-cbc","title":"v10: \"AES-CBC\"","text":"<pre><code>[AES-CBC] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =10\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(P + pad) + auth\niv: 16b\ne: AES(k, CBC, iv)\npad: NUL\nauth: sha256(v + iv + P + k)[:4]\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: CBC</li> <li>IV: 16 bytes, random, prepended in <code>cpl</code></li> <li>Padding: NUL bytes to block boundary</li> <li>Authentication: First 4 bytes of <code>SHA256(v + iv + P + k)</code>, exposed</li> <li>cpl layout: <code>[iv (16)] + [ciphertext] + [auth (4)]</code></li> <li>Use Case: Mnemonics, passphrases, short secrets</li> <li>Security Note: When encrypting: do not re-use IV, fail \"unsafe\" if plaintext ends 0x00</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v11-aes-cbc-p","title":"v11: \"AES-CBC +p\"","text":"<pre><code>[AES-CBC +p] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =11\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(P + auth + pad)\niv: 16b\ne: AES(k, CBC, iv)\nauth: sha256(P)[:4]\npad: PKCS7\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: CBC</li> <li>IV: 16 bytes, random, prepended in <code>cpl</code></li> <li>Padding: PKCS7 to block boundary</li> <li>Authentication: First 4 bytes of <code>SHA256(plaintext)</code>, hidden</li> <li>cpl layout: <code>[iv] + [ciphertext]</code> (auth embedded before padding/encryption)</li> <li>Use Case: General mid-sized plaintext</li> <li>Security Note: When encrypting: do not re-use IV</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v12-aes-cbc-c","title":"v12: \"AES-CBC +c\"","text":"<pre><code>[AES-CBC +c] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =12\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(zlib(P, wbits=-10) + auth + pad)\niv: 16b\ne: AES(k, CBC, iv)\nauth: sha256(zlib(P, wbits=-10))[:4]\npad: PKCS7\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: CBC</li> <li>IV: 16 bytes, random, prepended in <code>cpl</code></li> <li>Compression: <code>zlib.compress(P, wbits=-10)</code>, - raw deflate</li> <li>Padding: PKCS7 to block boundary</li> <li>Authentication: First 4 bytes of <code>SHA256(compressed plaintext)</code>, hidden</li> <li>cpl layout: <code>[iv (16)] + [ciphertext]</code> (auth embedded after compression, before padding/encryption)</li> <li>Use Case: Larger plaintext</li> <li>Security Note: When encrypting: do not re-use IV</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v15-aes-ctr","title":"v15: \"AES-CTR\"","text":"<pre><code>[AES-CTR] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =15\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(P + auth)\niv: 12b\ne: AES(k, CTR, iv)\nauth: sha256(P)[:4]\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: CTR</li> <li>IV: 12 bytes, random, prepended in <code>cpl</code></li> <li>Padding: None</li> <li>Authentication: First 4 bytes of <code>SHA256(plaintext)</code>, hidden</li> <li>cpl layout: <code>[iv (12)] + [ciphertext]</code> (auth embedded before padding/encryption)</li> <li>Use Case: Small to mid-sized plaintext</li> <li>Security Note: When encrypting: do not re-use IV</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v16-aes-ctr-c","title":"v16: \"AES-CTR +c\"","text":"<pre><code>[AES-CTR +c] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =16\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(zlib(P, wbits=-10) + auth)\niv: 12b\ne: AES(k, CTR, iv)\nauth: sha256(zlib(P, wbits=-10))[:4]\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: CTR</li> <li>IV: 12 bytes, random, prepended in <code>cpl</code></li> <li>Compression: <code>zlib.compress(P, wbits=-10)</code>, - raw deflate</li> <li>Padding: None</li> <li>Authentication: First 4 bytes of <code>SHA256(compressed plaintext)</code>, hidden</li> <li>cpl layout: <code>[iv (12)] + [ciphertext]</code> (auth embedded after compression, before padding/encryption)</li> <li>Use Case: Larger plaintext</li> <li>Security Note: When encrypting: do not re-use IV</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v20-aes-gcm","title":"v20: \"AES-GCM\"","text":"<pre><code>[AES-GCM] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =20\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(P) + auth\niv: 12b\ne: AES(k, GCM, iv)\nauth: e.authtag[:4]\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: GCM</li> <li>IV/Nonce: 12 bytes, random, prepended in <code>cpl</code></li> <li>Padding: None</li> <li>Authentication: First 4 bytes of GCM authtag, exposed</li> <li>cpl layout: <code>[iv (12)] + [ciphertext] + [auth (4)]</code></li> <li>Use Case: DEFAULT: Small to mid-sized plaintext</li> <li>Security Note: When encrypting: do not re-use IV/Nonce</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#v21-aes-gcm-c","title":"v21: \"AES-GCM +c\"","text":"<pre><code>[AES-GCM +c] KEF bytes: len_id + id + v + i + cpl\nlen_id: 1b\nid: &lt;len_id&gt;b\nv: 1b; =21\ni: 3b big; =(i &gt; 10K) ? i : i * 10K\ncpl: iv + e.encrypt(zlib(P, wbits=-10)) + auth\niv: 12b\ne: AES(k, GCM, iv)\nauth: e.authtag[:4]\nk: pbkdf2_hmac_sha256(K, id, i)\n</code></pre> <ul> <li>Mode: GCM</li> <li>IV/Nonce: 12 bytes, random, prepended in <code>cpl</code></li> <li>Compression: <code>zlib.compress(P, wbits=-10)</code>, - raw deflate</li> <li>Padding: None</li> <li>Authentication: First 4 bytes of GCM authtag, exposed</li> <li>cpl layout: <code>[iv (12)] + [ciphertext] + [auth (4)]</code></li> <li>Use Case: DEFAULT: Larger plaintext</li> <li>Security Note: When encrypting: do not re-use IV/Nonce</li> </ul>"},{"location":"getting-started/features/encryption/kef-specifications/#summary-table","title":"Summary Table","text":"Ver Name Mode IV Padding Compress Authentication Method Auth Intended Use Case 0 AES-ECB v1 ECB \u2013 NUL No SHA256(plaintext)[:16] 16 B Legacy high-entropy 1 AES-CBC v1 CBC 16 NUL No SHA256(plaintext)[:16] 16 B Legacy high-entropy 5 AES-ECB ECB \u2013 NUL No SHA256(v+P+k)[:3] 3 B exposed Small, high-entropy 6 AES-ECB +p ECB \u2013 PKCS7 No SHA256(plaintext)[:4] 4 B General Mid-sized 7 AES-ECB +c ECB \u2013 PKCS7 Yes SHA256(compressed)[:4] 4 B Large; duplicate blocks 10 AES-CBC CBC 16 NUL No SHA256(v+iv+P+k)[:4] 4 B exposed Small, high-entropy 11 AES-CBC +p CBC 16 PKCS7 No SHA256(plaintext)[:4] 4 B General mid-sized 12 AES-CBC +c CBC 16 PKCS7 Yes SHA256(compressed)[:4] 4 B General large 15 AES-CTR CTR 12 \u2013 No SHA256(plaintext)[:4] 4 B General mid-sized 16 AES-CTR +c CTR 12 \u2013 Yes SHA256(compressed)[:4] 4 B General large 20 AES-GCM GCM 12 \u2013 No GCM authtag[:4] 4 B exposed Best, General mid-sized 21 AES-GCM +c GCM 12 \u2013 Yes GCM authtag[:4] 4 B exposed Best, General large"},{"location":"getting-started/features/encryption/kef-specifications/#kef-implementation-concepts","title":"KEF Implementation Concepts","text":"<p>Using examples from, and as an introduction to the reference KEF implementation, we'll quickly cover some basic concepts that may be helpful in getting started with your own KEF implementation.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#version-configuration","title":"Version Configuration","text":"<p>From the version details and summary table: note that all KEF versions can be defined as having a set of parameters which define that version's KEF rules. For ease-of-maintenance - and also for extending later, it may be useful to store these in a central configuration. Within our sample reference, these are defined by constants <code>kef.VERSIONS</code>, <code>kef.MODE_NUMBERS</code> and <code>kef.MODE_IVS</code>.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#choosing-a-version","title":"Choosing a Version","text":"<p>As soon as you have data to hide, KEF offers choices for which version to use. That choice may be made by the user, or by the implementation, based on what is being hidden, compatibility with others, and how it may be stored/transported. The sample reference uses a function named <code>kef.suggest_versions()</code> to make a choice based on user's preferred mode-of-operation, the plaintext being hidden, then optimizes for a smaller KEF envelope.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#encryption-decryption-and-authentication","title":"Encryption, Decryption, and Authentication","text":"<p>Once you know what you need to hide and how you want to hide it, you'll need something to perform the encryption. You'll start by stretching the user-supplied <code>key</code>, salted with <code>id</code> for a number of <code>iterations</code> to derive the 256-bit AES key. Next you'll need to encrypt the plaintext (possibly with a random <code>IV</code> / Nonce) according to the chosen KEF version, so that the result is a cipher-payload <code>cpl</code>. To reverse this process, you'll need something to decrypt and authenticate the cipher-payload <code>cpl</code> - again according to the rules of the particular KEF version. The sample reference uses a class named <code>kef.Cipher</code> for stretching the <code>key</code>, encrypting plaintext to <code>cpl</code>, and decrypting / authenticating <code>cpl</code> back into plaintext.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#padding-and-unpadding","title":"Padding and Unpadding","text":"<p>Depending on the mode-of-operation of your version, you may need to pad the plaintext. If so, there will also be a need to unpad during the decryption process. The sample reference uses functions named <code>kef.pad()</code> and <code>kef.unpad()</code>, which are called from inside the <code>kef.Cipher</code> object when encrypting and decrypting.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#data-compression-deflate-inflate","title":"Data Compression: Deflate &amp; Inflate","text":"<p>Depending on the version, you may also need to deflate plaintext so that it is compressed before encryption. Likewise, you'll need to reinflate it after decryption to decompress the plaintext. The sample reference uses functions named <code>kef.deflate()</code> and <code>kef.reinflate()</code>, which are also called from inside the <code>kef.Cipher</code> object when encrypting and decrypting.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#metadata-wrapping-and-unwrapping","title":"Metadata Wrapping and Unwrapping","text":"<p>After encryption, you'll need to wrap the <code>id</code>, <code>version</code>, <code>iterations</code> and <code>cpl</code> into a valid KEF envelope. Likewise, in order to reveal something hidden within a KEF envelope, you'll first need to unwrap, or parse it into its constituent parts (<code>id</code>, <code>version</code>, <code>iterations</code>, <code>cpl</code>) so that it may be decrypted as described above. The sample reference uses functions <code>kef.wrap()</code> and <code>kef.unwrap()</code> for these procedures.</p>"},{"location":"getting-started/features/encryption/kef-specifications/#on-further-encoding-kef-envelopes","title":"On Further Encoding KEF Envelopes","text":"<p>Outside the scope of this specification on KEF envelopes, which are strings of bytes, implementations will surely need to make choices about encoding/decoding schemes. Whether for QR transport, copy-pasting into messages, embedding into json documents, in-plain-sight within other document formats, or persisted in binary files, these choices are left to implementors.</p>"},{"location":"getting-started/features/printing/cnc/","title":"CNC Engraving","text":"<p>Warning/Disclaimer: This feature is intended for individuals with experience in electronics tinkering and soldering.</p> <p>Krux engraves any QR code (SeedQR, PSBT, address, XPUB, etc.) on GRBL 1.1 CNC machines \u2014 via airgapped SD card or direct TTL serial connection.</p> <p> </p> <p>A GRBL g-code simulation on OpenBuilds CONTROL:</p> <p> </p> <p>After configuring the CNC printer and driver in settings, any screen that displays a QR code will offer to <code>Print as QR</code>. Use this to Carve QR codes into wood/metal, like backups of your mnemonics, xpubs and multisig wallet output descriptor.</p> <p>If the driver is configured as FilePrinter, the output will be GRBL g-code in a qr.nc file on the SD card. If the driver is configured as GRBLPrinter, the output will be GRBL g-code sent directly to a GRBL controller via a TTL serial connection. A tested settings is presented below:</p> <pre><code>\"cnc\": {\n    \"unit\": \"mm\",\n    \"part_size\": 70.675,\n    \"flute_diameter\": 3.175,\n    \"depth_per_pass\": 1.0,\n    \"cut_depth\": 2.0,\n    \"border_padding\": 2.0,\n    \"plunge_rate\":300,\n    \"feed_rate\":650,\n    \"cut_method\": \"spiral\",\n    \"invert\": 1\n}\n</code></pre> <p>A 96\u00d796mm QR carved into black-painted wood with 2mm drill-bit (inverted for white):</p> <p></p> <p>A 50x50mm QR carved into black-painted wood with 2mm drill-bit (inverted for white):</p> <p></p> <p>Laser etching is also supported. Tested settings and results:</p> <pre><code>\"cnc\": {\n  \"unit\": \"mm\",\n  \"part_size\": 34,\n  \"flute_diameter\": 0.2,\n  \"depth_per_pass\": 0.01,\n  \"cut_depth\": 0.01,\n  \"border_padding\": 0.0,\n  \"plunge_rate\": 150,\n  \"feed_rate\": 300,\n  \"cut_method\": \"row\",\n  \"invert\": 0,\n  \"head_type\": \"laser\",\n  \"head_power\": 500\n}\n</code></pre> <p>From left to right: 34x34mm at 50%, 21x21mm at 5%, 21x21mm at 50% power laser-etched stainless steel:</p> <p></p> <p>Note: Just be careful what you do with the printed codes, since most smartphones can now quickly and easily read QR codes. Treat your QR mnemonic the same way you would treat a plaintext copy of it.</p>"},{"location":"getting-started/features/printing/printing/","title":"Printing","text":"<p>Warning/Disclaimer: This feature is intended for individuals with experience in electronics tinkering and soldering.</p> <p>Krux has the ability to print mnemonic backup (Words, Numbers, Tinyseed template; but not Stackbit 1248) and any QR code (SeedQR, signed PSBT, Address, XPUB, Wallet output descriptor, ...) via a locally-connected TTL serial thermal printer. Consult the parts list page for supported printers.</p> <p> </p> <p> </p> <p>Once a thermal printer and driver have been enabled in settings, all screens that display a QR code will offer the option to <code>Print as QR</code>. Other formats of mnemonic backup will also ask if you want to <code>Print as QR?</code>. </p> <p>There are many ways you can use this functionality, including:</p> <ul> <li>Printing backups of your mnemonics and multisig wallet output descriptor.</li> <li>Printing your xpubs and receive addresses to share.</li> <li>Printing signed messages and PSBTs.</li> </ul> <p>Since printed thermal paper fades quickly, you can also print your backups on sticker thermal paper to use as templates for punching into more resilient materials like steel.</p> <p>Note: Just be careful what you do with the printed codes, since most smartphones can now quickly and easily read QR codes. Treat your QR mnemonic the same way you would treat a plaintext copy of it.</p>"},{"location":"getting-started/installing/from-pre-built-release/","title":"From pre-built official release","text":"<p>This page explains how to download and install Krux firmware from our official, pre-built latest release.</p> <p></p>"},{"location":"getting-started/installing/from-pre-built-release/#verify-the-files","title":"Verify the files","text":"<p>Before installing the release, it's a good idea to check that:</p> <ol> <li>The SHA256 hash of <code>krux-v25.10.1.zip</code> matches the hash in <code>krux-v25.10.1.zip.sha256.txt</code></li> <li>The signature file <code>krux-v25.10.1.zip.sig</code> can be verified with the <code>selfcustody.pem</code> public key found in the root of the krux repository.</li> </ol> <p>You can either do this manually or with the <code>krux</code> shell script, which contains helper commands for this: <pre><code>### Using krux script ###\n# Hash checksum\n./krux sha256 krux-v25.10.1.zip\n# Signature\n./krux verify krux-v25.10.1.zip selfcustody.pem\n\n### Manually ###\n# Hash checksum\nsha256sum krux-v25.10.1.zip.sha256.txt -c\n#Signature\nopenssl sha256 &lt;krux-v25.10.1.zip -binary | openssl pkeyutl -verify -pubin -inkey selfcustody.pem -sigfile krux-v25.10.1.zip.sig\n</code></pre></p> <p>On Mac you may need to install <code>coreutils</code> to be able to use <code>sha256sum</code> <pre><code>brew install coreutils\n</code></pre></p> <p>Fun fact: Each new Krux release is signed with Krux!</p>"},{"location":"getting-started/installing/from-pre-built-release/#flash-the-firmware-onto-the-device","title":"Flash the firmware onto the device","text":"<p>Extract the latest version of Krux you downloaded and enter the folder: <pre><code>unzip krux-v25.10.1.zip &amp;&amp; cd krux-v25.10.1\n</code></pre></p> <p>Connect the device to your computer via USB (for Maix Amigo, make sure you\u2019re using bottom port), power it on, and run the following, replacing <code>DEVICE</code> with either <code>m5stickv</code>, <code>amigo</code>, <code>cube</code> or <code>yahboom</code> (to Yahboom you may need to manually specify the port, for example <code>/dev/ttyUSB0</code> on Linux or <code>COM6</code> on Windows): <pre><code>./ktool -B goE -b 1500000 maixpy_DEVICE/kboot.kfpkg\n</code></pre></p> <p>For <code>dock</code>, <code>wonder_mv</code> or <code>tzt</code> use the <code>-B dan</code> parameter: <pre><code>./ktool -B dan -b 1500000 maixpy_DEVICE/kboot.kfpkg\n</code></pre></p> <p>When the flashing process completes, you should see the Krux logo:</p> <p> </p> <p>If it doesn't, try turning your device off and on by holding down the power button for six seconds.</p> <p>Congrats, you're now running Krux!</p>"},{"location":"getting-started/installing/from-pre-built-release/#a-note-about-the-maix-amigo","title":"A note about the Maix Amigo","text":"<p>Some Amigo screens have inverted X coordinates, others display colors differently. For more info see Troubleshooting.</p>"},{"location":"getting-started/installing/from-pre-built-release/#troubleshooting","title":"Troubleshooting","text":"<p>If <code>ktool</code> fails to run, you may need to give it executable permissions with <code>chmod +x ./ktool</code>, or you might need to use \"sudo\" if your user don't have access to serial port. In Windows or Mac you may need to explicitly allow the tool to run by adding an exception for it.</p> <p>If the flashing process fails midway through, check the connection, restart the device, and try the command again.</p> <p>Two serial ports are created when <code>Amigo</code> are connected to a PC. Sometimes Ktool will pick the wrong port and flashing will fail. Manually specify the serial port to overcome this issue using <code>-p</code> argument:</p>"},{"location":"getting-started/installing/from-pre-built-release/#linux","title":"Linux","text":"<p>See the correct port using <code>ls /dev/ttyUSB*</code>, in the example below we use <code>/dev/ttyUSB0</code>: <pre><code>./ktool-linux -B goE -b 1500000 maixpy_amigo/kboot.kfpkg -p /dev/ttyUSB1\n</code></pre></p>"},{"location":"getting-started/installing/from-pre-built-release/#windows","title":"Windows","text":"<p>See the correct port at Device Manager -&gt; Ports (COM &amp; LPT), in the example below we use <code>COM6</code>: <pre><code>.\\ktool-win.exe -B goE -b 1500000 maixpy_amigo\\kboot.kfpkg -p COM6\n</code></pre></p>"},{"location":"getting-started/installing/from-pre-built-release/#mac","title":"Mac","text":"<p>Remove the Gatekeeper quarantine extended attribute from ktool-mac: <pre><code>xattr -d com.apple.quarantine ktool-mac\n</code></pre></p> <p>See the correct port using the command line: <code>ls /dev/cu.usb*</code>, in the example below we use <code>/dev/cu.usbserial-10</code> (If the output isn't what you expect try a different cable, preferably a smartphone usb-c charger cable): <pre><code>./ktool-mac -B goE -b 1500000 maixpy_amigo/kboot.kfpkg -p /dev/cu.usbserial-10\n</code></pre></p> <p>Different OS versions may have different port names, and the absence of ports may indicate a connection, driver or hardware related issue. See Troubleshooting for more info.</p>"},{"location":"getting-started/installing/from-pre-built-release/#tips","title":"Tips","text":""},{"location":"getting-started/installing/from-pre-built-release/#multilingual-support","title":"Multilingual support","text":"<p>Prefer a different language? Krux has support for multiple languages. Once at the start screen, go to <code>Settings</code>, followed by <code>Locale</code>, and select the locale you wish to use.</p>"},{"location":"getting-started/installing/from-pre-built-release/#upgrade-via-microsd-card","title":"Upgrade via microSD card","text":"<p>Once you've installed the initial firmware on your device via USB, you can either continue updating the device by flashing or you can perform further upgrades via microSD card to keep the device airgapped.</p>"},{"location":"getting-started/installing/from-source/","title":"From source","text":"<p>This page explains how to install Krux from source. You can check a simplified version of these instructions in our README too.</p>"},{"location":"getting-started/installing/from-source/#fetch-the-code","title":"Fetch the code","text":"<p>This will download the source code of Krux as well as the code of all its dependencies inside a new folder called <code>krux</code> (needs <code>git</code>): <pre><code>git clone --recurse-submodules https://github.com/selfcustody/krux\n</code></pre></p> <p>Note: When you wish to pull updates (to all submodules, their submodules, ...) to this repo, use: <pre><code>git pull origin main &amp;&amp; git submodule update --init --recursive\n</code></pre></p>"},{"location":"getting-started/installing/from-source/#prerequisite-for-upgrading-via-microsd","title":"Prerequisite for upgrading via microSD","text":"<p>If you wish to perform airgapped upgrades via microSD card later, you will need to have a private and public key pair to sign your builds and verify the signatures. If you do not want to perform further airgapped upgrades, jump to build section.</p> <p>You can use an existing Krux installation and mnemonic to sign your builds with, or you can generate a keypair and sign from the <code>openssl</code> CLI. Commands have been added to the <code>krux</code> shell script to make this easier.</p> <p>In either case, you will need to update the <code>SIGNER_PUBKEY</code> field in <code>src/krux/metadata.py</code> to store your public key so that Krux can verify future builds before installing.</p> <p>To generate a keypair: <pre><code>./krux generate-keypair\n./krux pem-to-pubkey pubkey.pem\n</code></pre></p> <p>The first command will create <code>privkey.pem</code> and <code>pubkey.pem</code> files you can use with openssl, and the second command will output your public key in the form expected by Krux.</p> <p>Once you've updated the <code>SIGNER_PUBKEY</code> with this value, you can proceed with the regular build process.</p>"},{"location":"getting-started/installing/from-source/#build-the-firmware-linux-or-wsl","title":"Build the firmware (Linux or WSL)","text":"<p>The krux bash script contains commands for common development tasks. It assumes a Linux host, you will need to have Docker Desktop or Docker Engine, <code>openssl</code>, and <code>wget</code> installed at a minimum for the commands to work as expected. It works on Windows using WSL. The channel Crypto Guide from Youtube made a step-by-step video - Krux DIY Bitcoin Signer: Build From Source &amp; Verify (With Windows + WSL2 + Docker)</p> <p>To build and flash the firmware: <pre><code># build firmware for Maix Amigo\n./krux build maixpy_amigo\n</code></pre></p> <p>The first time, the build can take around an hour or so to complete. Subsequent builds should take only a few minutes. If all goes well, you should see a new <code>build</code> folder containing <code>firmware.bin</code> and <code>kboot.kfpkg</code> files when the build completes.</p> <p>Note: if you encounter any of these errors while building, it is a problem connecting to github, try again (if the error persists, try changing the DNS/VPN or correcting the hostname resolution of github.com to an IP that is working for you): <pre><code>error: RPC failed; curl 92 HTTP/2 stream 0 was not closed cleanly: CANCEL (err8)\nfatal: the remote end hung up unexpectedly\nfatal: early EOF\nfatal: index-pack failed\nfatal: clone of ... failed\nFailed to clone ...\n</code></pre></p>"},{"location":"getting-started/installing/from-source/#reproducibility","title":"Reproducibility","text":"<p>If you build from the <code>main</code> branch of the source code, you should be able to reproduce the build process used to generate the latest release binaries and obtain exactly the same copies of the <code>firmware.bin</code> and <code>kboot.kfpkg</code> files, with matching hash checksums (to check for an older version, use the <code>tag</code> instead).</p> <p>To check, use the compiled files for the target device. Each command should output the same hash for the two provided files: <pre><code>sha256sum build/firmware.bin krux-v25.10.1/maixpy_DEVICE/firmware.bin\nsha256sum build/kboot.kfpkg krux-v25.10.1/maixpy_DEVICE/kboot.kfpkg\n</code></pre></p> <p>If you want to extract and verify the <code>firmware.bin</code>file contained in <code>kboot.kfpkg</code>, use the following:</p> <pre><code>unzip kboot.kfpkg -d ./kboot/\n</code></pre>"},{"location":"getting-started/installing/from-source/#flash-the-firmware-onto-the-device","title":"Flash the firmware onto the device","text":"<p>Connect the device to your computer via USB (for Maix Amigo, make sure you\u2019re using bottom port), power it on, and run the following, replacing <code>DEVICE</code> with either <code>m5stickv</code>, <code>amigo</code>, <code>cube</code>, <code>dock</code>, <code>yahboom</code>, <code>wonder_mv</code> or <code>tzt</code>: <pre><code># flash firmware to DEVICE\n./krux flash maixpy_DEVICE\n</code></pre> If flashing fails try reading Troubleshooting</p> <p>When the flashing process completes, you should see the Krux logo:</p> <p> </p> <p>If it doesn't, try turning your device off and on by holding down the power button for six seconds.</p> <p>Congrats, you're now running Krux!</p>"},{"location":"getting-started/installing/from-source/#a-note-about-the-maix-amigo","title":"A note about the Maix Amigo","text":"<p>Some Amigo screens have inverted X coordinates, others display colors differently. For more info see Troubleshooting.</p>"},{"location":"getting-started/installing/from-source/#signing-the-firmware","title":"Signing the firmware","text":"<p>You can sign the firmware to perform airgapped upgrades using one of the two methods listed below:</p>"},{"location":"getting-started/installing/from-source/#method-1-signing-from-krux","title":"Method 1: Signing from Krux","text":"<p>First, calculate the SHA256 hash of the new firmware by running: <pre><code>./krux sha256 build/firmware.bin\n</code></pre></p> <p>Copy this hex string and turn it into a QR code using whichever QR code generator you'd like.</p> <p>In Krux, enter the mnemonic of your private key that will be used for signing, and go to Sign -&gt; Message. Scan the QR code you generated, and you will be asked if you wish to sign the hash. Proceed, and you will be presented with a base64-encoded string containing the signature, as text and as a QR code.</p> <p>Take this string and create a signature file by running: <pre><code>./krux b64decode \"signature-in-base64\" &gt; build/firmware.bin.sig\n</code></pre></p> <p>This will generate a <code>firmware.bin.sig</code> file containing a signature of the firmware's SHA256 hash.</p>"},{"location":"getting-started/installing/from-source/#method-2-signing-from-your-computer-with-openssl","title":"Method 2: Signing from your computer with OpenSSL","text":"<p>With the keypair you generated before, you can now run: <pre><code>./krux sign build/firmware.bin privkey.pem\n</code></pre></p> <p>This will generate a <code>firmware.bin.sig</code> file containing a signature of the firmware's SHA256 hash.</p>"},{"location":"getting-started/installing/from-test-release/","title":"From pre-built test release","text":"<p>This page explains how to install Krux from a test (beta), pre-built release.</p>"},{"location":"getting-started/installing/from-test-release/#warning","title":"Warning","text":"<p>Keep in mind that these are unsigned binaries.</p>"},{"location":"getting-started/installing/from-test-release/#download","title":"Download","text":"<p>Download experimental compiled firmware at test (beta) repository or the Mobile Android app <code>apk</code> at KruxMobileApp.</p>"},{"location":"getting-started/installing/from-test-release/#mobile-android","title":"Mobile - Android","text":"<p>The Krux Mobile Android app is designed for learning about Krux and Bitcoin air-gapped transactions. Due to the numerous potential vulnerabilities inherent in smartphones, such as the lack of control over the operating system, libraries, and hardware peripherals, the Krux app should NOT be used to manage wallets containing savings or important keys and mnemonics. For secure management of your keys, a dedicated device is recommended.</p>"},{"location":"getting-started/installing/from-test-release/#compiled-firmware-for-kendryte-k210-devices","title":"Compiled firmware for Kendryte K210 devices","text":""},{"location":"getting-started/installing/from-test-release/#m5stickv","title":"M5StickV","text":"<p>To Flash M5StickV run the following.</p>"},{"location":"getting-started/installing/from-test-release/#linux","title":"Linux","text":"<pre><code>./ktool-linux -B goE -b 1500000 maixpy_m5stickv/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#mac","title":"Mac","text":"<pre><code>./ktool-mac -B goE -b 1500000 maixpy_m5stickv/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#windows","title":"Windows","text":"<pre><code>.\\ktool-win.exe -B goE -b 1500000 maixpy_m5stickv\\kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#sipeed-maix-amigo","title":"Sipeed Maix Amigo","text":"<p>To Flash Maix Amigo run the following.</p>"},{"location":"getting-started/installing/from-test-release/#linux_1","title":"Linux","text":"<pre><code>./ktool-linux -B goE -b 1500000 maixpy_amigo/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#mac_1","title":"Mac","text":"<pre><code>./ktool-mac -B goE -b 1500000 maixpy_amigo/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#windows_1","title":"Windows","text":"<pre><code>.\\ktool-win.exe -B goE -b 1500000 maixpy_amigo\\kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#a-note-about-the-maix-amigo","title":"A note about the Maix Amigo","text":"<p>Some Amigo screens have inverted X coordinates, others display colors differently. For more info see Troubleshooting.</p>"},{"location":"getting-started/installing/from-test-release/#sipeed-maix-cube","title":"Sipeed Maix Cube","text":"<p>To Flash Maix Cube run the following.</p>"},{"location":"getting-started/installing/from-test-release/#linux_2","title":"Linux","text":"<pre><code>./ktool-linux -B goE -b 1500000 maixpy_cube/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#mac_2","title":"Mac","text":"<pre><code>./ktool-mac -B goE -b 1500000 maixpy_cube/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#windows_2","title":"Windows","text":"<pre><code>.\\ktool-win.exe -B goE -b 1500000 maixpy_cube\\kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#sipeed-maix-dock","title":"Sipeed Maix Dock","text":"<p>To Flash Maix Dock you need to pass the <code>-B dan</code> parameter.</p>"},{"location":"getting-started/installing/from-test-release/#linux_3","title":"Linux","text":"<pre><code>./ktool-linux -B dan -b 1500000 maixpy_dock/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#mac_3","title":"Mac","text":"<pre><code>./ktool-mac -B dan -b 1500000 maixpy_dock/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#windows_3","title":"Windows","text":"<pre><code>.\\ktool-win.exe -B dan -b 1500000 maixpy_dock\\kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#aimotion-yahboom-k210-module","title":"Aimotion Yahboom k210 module","text":"<p>To Flash Yahboom k210 module you'll have to manually specify the port.</p>"},{"location":"getting-started/installing/from-test-release/#linux_4","title":"Linux","text":"<p>See the correct port using <code>ls /dev/ttyUSB*</code>, in the example below we use <code>/dev/ttyUSB0</code>: <pre><code>./ktool-linux -B goE -b 1500000 -p /dev/ttyUSB0 maixpy_yahboom/kboot.kfpkg\n</code></pre></p>"},{"location":"getting-started/installing/from-test-release/#mac_4","title":"Mac","text":"<p>See the correct port using the command line: <code>ls /dev/cu.usbserial*</code>, in the example below we use <code>/dev/cu.usbserial-10</code>: <pre><code>./ktool-mac -B goE -b 1500000 -p /dev/cu.usbserial-10 maixpy_yahboom/kboot.kfpkg\n</code></pre></p>"},{"location":"getting-started/installing/from-test-release/#windows_4","title":"Windows","text":"<p>See the correct port at Device Manager -&gt; Ports (COM &amp; LPT), in the example below we use <code>COM6</code>: <pre><code>.\\ktool-win.exe -B goE -b 1500000 -p COM6 maixpy_yahboom\\kboot.kfpkg\n</code></pre></p>"},{"location":"getting-started/installing/from-test-release/#hiwonder-wondermv-vision-recognition-module","title":"Hiwonder WonderMV Vision Recognition Module","text":"<p>To Flash WonderMV you need to pass the <code>-B dan</code> parameter.</p>"},{"location":"getting-started/installing/from-test-release/#linux_5","title":"Linux","text":"<pre><code>./ktool-linux -B dan -b 1500000 maixpy_wonder_mv/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#mac_5","title":"Mac","text":"<pre><code>./ktool-mac -B dan -b 1500000 maixpy_wonder_mv/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#windows_5","title":"Windows","text":"<pre><code>.\\ktool-win.exe -B dan -b 1500000 maixpy_wonder_mv\\kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#tzt","title":"TZT","text":"<p>To Flash TZT you need to pass the <code>-B dan</code> parameter.</p>"},{"location":"getting-started/installing/from-test-release/#linux_6","title":"Linux","text":"<pre><code>./ktool-linux -B dan -b 1500000 maixpy_tzt/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#mac_6","title":"Mac","text":"<pre><code>./ktool-mac -B dan -b 1500000 maixpy_tzt/kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/from-test-release/#windows_6","title":"Windows","text":"<pre><code>.\\ktool-win.exe -B dan -b 1500000 maixpy_tzt\\kboot.kfpkg\n</code></pre>"},{"location":"getting-started/installing/","title":"Installing","text":"<p>You can install Krux in four different ways:</p> <ul> <li> Using Krux-Installer GUI application</li> <li> From pre-built official release</li> <li> From pre-built test (beta) release</li> <li> From source</li> </ul>"},{"location":"getting-started/installing/#requirements","title":"Requirements","text":"<p>Please, check the parts list for the compatible devices and requirements.</p> <p>After the first firmware install, you can use a microSD card if you wish to perform further airgapped updates.</p>"},{"location":"getting-started/installing/from-gui/debian-like/","title":"Download assets","text":"<ul> <li><code>krux_installer_0.0.21_amd64.deb</code></li> </ul>"},{"location":"getting-started/installing/from-gui/debian-like/#install","title":"Install","text":"<p>Krux-Installer isn't available on Debian or Ubuntu repositories. Therefore, only the <code>apt-get install</code> command will not work.  To install, it'll be necessary two steps:</p> <ul> <li>Install the .deb package itself:</li> </ul> <pre><code>sudo dpkg -i krux_installer_0.0.21_amd64.deb\n</code></pre> <ul> <li>Update the installed package:</li> </ul> <pre><code>sudo apt-get install -f\n</code></pre> <p>It will warn you that your system user was added to <code>dialout</code> group and maybe you need to reboot to activate the <code>sudoless</code> flash procedure.</p>"},{"location":"getting-started/installing/from-gui/debian-like/#after-install","title":"After install","text":"<p>Once done, you will use Krux-Installer GUI to perform the firmware installation. </p>"},{"location":"getting-started/installing/from-gui/fedora-like/","title":"Download assets","text":"<ul> <li><code>krux_installer-0.0.21-1.x86_64.rpm</code></li> </ul>"},{"location":"getting-started/installing/from-gui/fedora-like/#install","title":"Install","text":"<p>Krux-Installer isn't available on Fedora or RedHat repositories. You'll need to add it manually:</p>"},{"location":"getting-started/installing/from-gui/fedora-like/#fedora","title":"Fedora","text":"<pre><code>sudo dnf install krux_installer-0.0.21-1.x86_64.rpm\n</code></pre>"},{"location":"getting-started/installing/from-gui/fedora-like/#other-redhat-based-distros","title":"Other RedHat based distros:","text":"<pre><code>sudo yum localinstall krux_installer-0.0.21-1.x86_64.rpm\n</code></pre> <p>It will warn you that your system user was added to <code>dialout</code> group and maybe you need to reboot to activate the <code>sudoless</code> flash procedure.</p>"},{"location":"getting-started/installing/from-gui/fedora-like/#after-install","title":"After install","text":"<p>Once done, you will use Krux-Installer GUI to perform the firmware installation. </p>"},{"location":"getting-started/installing/from-gui/","title":"From GUI application","text":"<p>You can install Krux (both official or beta releases) onto your K210-based device using our official desktop application, Krux-Installer:</p> <p></p> <p>Install instructions:</p> <ul> <li> Don't trust, verify</li> <li> Windows</li> <li> MacOS Intel or M1/M2/M3 (ARM64)</li> <li> Debian and like</li> <li> Fedora and like</li> <li> Other linux distros</li> </ul> <p>\u26a0\ufe0f  If you find any bug, please submit a issue here.</p>"},{"location":"getting-started/installing/from-gui/macos/","title":"Download assets","text":"<p>M1/M2/M3 (ARM64):</p> <ul> <li><code>krux_installer_0.0.21_arm64.dmg</code></li> </ul>"},{"location":"getting-started/installing/from-gui/macos/#install","title":"Install","text":"<p>Open the <code>dmg</code> file and a new volume will be presented; drag'n'drop the Krux-Installer to the Applications folder:</p> <p></p> <p>Before run, you'll need to remove the quarantine flag from application. This occurs because we have not added the Apple's code signing and notarization.</p> <p>To fix this, open your terminal and execute the following command:</p> <pre><code>xattr -d com.apple.quarantine -r /Applications/krux-installer.app\n</code></pre>"},{"location":"getting-started/installing/from-gui/macos/#after-install","title":"After install","text":"<p>Once done, you will use Krux-Installer GUI to perform the firmware installation. </p>"},{"location":"getting-started/installing/from-gui/other-linux-distro/","title":"Download assets","text":"<p>For this installation, we'll use the <code>.deb</code> sources:</p> <ul> <li><code>krux_installer_0.0.21_amd64.deb</code></li> </ul>"},{"location":"getting-started/installing/from-gui/other-linux-distro/#install","title":"Install","text":"<p>This step it's not really an installation. At least it will make the program's binary available somewhere on your computer; it can be useful if you want to develop a package for your distro.</p> <p>To do this you'll need two tools:</p> <ul> <li><code>ar</code>;</li> <li><code>bsdtar</code>.</li> </ul>"},{"location":"getting-started/installing/from-gui/other-linux-distro/#extract-contents","title":"Extract contents","text":"<ul> <li>Extract the <code>.deb</code> contents:</li> </ul> <pre><code>ar xv krux_installer_0.0.21_amd64.deb\n</code></pre> <ul> <li>Extract the <code>data.tar.zst</code> contents:</li> </ul> <pre><code>bsdtar -xvf data.tar.zst\n</code></pre> <p>The binary will be located at <code>./usr/local/bin/krux-installer</code>. </p>"},{"location":"getting-started/installing/from-gui/other-linux-distro/#after-install","title":"After install","text":"<p>Once done, you will use Krux-Installer GUI to perform the firmware installation. </p>"},{"location":"getting-started/installing/from-gui/usage/","title":"Usage","text":"<p>This guide will walk through the basic use of the installer. At startup, it can differ in some operational systems. In the rest, the procedures will be similar.</p>"},{"location":"getting-started/installing/from-gui/usage/#main-menu","title":"Main Menu","text":"<p>When executing the Krux-Installer, you will be presented with a menu of 4 enabled buttons and two disabled buttons:</p> <p></p> <ul> <li> <p>Enabled buttons:</p> <ul> <li> <p><code>Version</code>: select a firmware version;</p> </li> <li> <p><code>Device</code>: select a supported device for the selected version;</p> </li> <li> <p><code>Settings</code>: change some application settings;</p> </li> <li> <p><code>About</code>: just show some information about the application.</p> </li> </ul> </li> <li> <p>Disabled buttons:</p> <ul> <li> <p><code>Flash firmware</code>: This button will start the flash firmware procedure;</p> <ul> <li>It will be enabled when user select both version and device;</li> </ul> </li> <li> <p><code>Wipe device</code>: This button will start the wipe device procedure.</p> <ul> <li>It will be enabled when user select the device.</li> </ul> </li> </ul> </li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#kivy-fatal-error-opengl","title":"Kivy Fatal Error - OpenGL","text":"<p>Our latest version uses Kivy and requires at least OpenGL version 2.0, if you encounter this error, try installing the OpenCL\u2122, OpenGL\u00ae, and Vulkan\u00ae Compatibility Pack from Microsoft.</p> <p></p>"},{"location":"getting-started/installing/from-gui/usage/#select-version","title":"Select version","text":"<p>At startup, the application will setup it to the latest one, <code>krux-v25.10.1</code>. But you can select even a beta release or older versions:</p> <p></p> <ul> <li> <p>Click in the button that show the text <code>Version: krux-v25.10.1</code>;</p> </li> <li> <p>To select a beta release, click on button that show the text <code>odudex/krux_binaries</code>;</p> </li> <li> <p>To select an older version, click on button that show the text <code>Old versions</code>;</p> </li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#beta-release","title":"Beta release","text":"<p>After choose <code>odudex/krux_binaries</code>, you'll be warned with a message:</p> <p></p>"},{"location":"getting-started/installing/from-gui/usage/#older-versions","title":"Older versions","text":"<ul> <li>We put this option in case you have any interest in the history of firmware development;</li> </ul> <ul> <li> <p>Each version supports one device or the other;</p> </li> <li> <p>For example: the version <code>v22.03.0</code> has support only for <code>m5stickv</code>.</p> </li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#settings","title":"Settings","text":"<p>Krux-Installer will give to you some freedom of choices for:</p> <ul> <li> <p>Krux-Installer settings;</p> </li> <li> <p>General settings;</p> </li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#krux-installer-specific-settings","title":"Krux-Installer specific settings","text":"<p>Here you can configure some of the specifics of krux firmare, like:</p> <p></p> <ul> <li> <p>Where you'll save downloaded assets;</p> </li> <li> <p>The flash baudrate </p> </li> <li> <p>The natural language that will be used in the application (system locale).</p> </li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#flash-baudrate","title":"Flash baudrate","text":"<p>The flash baudrate is how quickly the firmware will be written to the device.</p> <p></p> <p>Use one of the following (m5StickV doesn't support 2000000): 9600, 19200, 28800, 38400, 57600, 76800, 115200, 230400, 460800, 576000, 921600, 1500000, 2000000.</p>"},{"location":"getting-started/installing/from-gui/usage/#system-locale","title":"System locale","text":"<p>At startup, Krux-Installer recognize the locale used in your system. If your language isn't supported, it will defaults to <code>en_US</code>.</p> <p></p>"},{"location":"getting-started/installing/from-gui/usage/#select-device","title":"Select Device","text":"<p>Everytime you select a new version, you'll see that the device button will be reseted to <code>Device: select a new one</code> state. Once a version is selected you can choose a device on which the firmware will be written.</p> <p>First, select the device we want to flash. After that the menu will shown three items:</p> <p></p> <p>Note that some devices may be disabled if they are not supported by the chosen version</p>"},{"location":"getting-started/installing/from-gui/usage/#flash-device","title":"Flash device","text":"<p>Once you choose the device and version, it enables the \"flash device\" button. It will start an automatic process of:</p> <ul> <li> <p>For official firmware's releases:</p> <ul> <li> <p>Warning;</p> </li> <li> <p>Download;</p> </li> <li> <p>Verification:</p> </li> <li> <p>Unzip the correct firmware;</p> </li> <li> <p>Flash:</p> <ul> <li> <p>The flash itself via USB;</p> </li> <li> <p>Air-gapped update via SD card;</p> </li> </ul> </li> </ul> </li> <li> <p>For beta releases:</p> <ul> <li> <p>Download asset;</p> </li> <li> <p>The flash itself;</p> </li> </ul> </li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#warning","title":"Warning","text":"<p>If you already downloaded assets, you'll be warned about this and will be offered the possibility to download again or continue without downloading:</p> <p></p>"},{"location":"getting-started/installing/from-gui/usage/#download","title":"Download","text":"<p>Krux-Installer download can download four assets for official releases or one for beta releases.</p>"},{"location":"getting-started/installing/from-gui/usage/#official-releases","title":"Official releases","text":"<ul> <li> <p>A <code>zip</code> file containing all firmwares for each device;</p> </li> <li> <p>Download a <code>zip.sha256.txt</code> file containing a <code>zip</code>'s digital fingerprint;</p> </li> <li> <p>Download a <code>zip.sig</code> file containing a <code>zip</code>'s digital signature;</p> </li> <li> <p>Download the <code>selfcustody.pem</code> file containing a public key certificate, signed by <code>odudex</code>;</p> </li> </ul> <p></p>"},{"location":"getting-started/installing/from-gui/usage/#beta-releases","title":"Beta releases","text":"<ul> <li>A <code>kfpkg</code> file containing the specific firmware for choosen device;</li> </ul>"},{"location":"getting-started/installing/from-gui/usage/#verification","title":"Verification","text":"<ul> <li> <p>Integrity verification compares the computed hash of <code>zip</code> against thei provided <code>zip.sha256.txt</code>;</p> </li> <li> <p>Authenticity verification check if the <code>zip</code> file was really signed by <code>odudex</code>, using the <code>zip.sig</code> and <code>selfcustody.pem</code>.</p> </li> </ul> <p></p>"},{"location":"getting-started/installing/from-gui/usage/#unzip","title":"Unzip","text":"<p>Now you will be able to select if you do a flash process or need to do an airgap process:</p> <p></p> <p>Click on Flash with to install via USB or Air-gapped update with to perform upgrades via an SD card.</p>"},{"location":"getting-started/installing/from-gui/usage/#flash-with","title":"Flash with","text":"<p>When flash starts, it will warn you to not disconnect the device until the process is complete. You'll be able to see the flash progress:</p> <p></p> <p>\u26a0\ufe0f  TIP: You must connect and turn on your device before click extract and flashing starts!.</p> <p>As well a done icon:</p> <p></p> <p>\u26a0\ufe0f  TIP: When the flashing process completes, you should see the Krux logo:</p> <p> </p> <p>If it doesn't, try turning your device off and on by holding down the power button for six seconds.</p> <p>Congrats, you're now running Krux!</p>"},{"location":"getting-started/installing/from-gui/usage/#error-flashing","title":"Error flashing","text":"<p>If Krux-Installer shows a flash failed error or freezes at PLEASE DO NOT UNPLUG YOUR DEVICE with the message INFO Trying to Enter K210 ROM ISP Mode\u2026, it means the installer couldn\u2019t establish a proper connection to the device. See the troubleshooting section for guidance on how to fix this.</p>"},{"location":"getting-started/installing/from-gui/usage/#air-gapped-update-with","title":"Air-gapped update with","text":"<p>Once you've installed the initial firmware on your device via USB, you can perform further firmware upgrades via SD card to keep the device airgapped.</p> <p></p> <p>\u26a0\ufe0f Click on \"Air-gapped update with\"</p> <p>Once the <code>firmware.bin</code> and <code>firmware.bin.sig</code> are extracted, you'll see a warning message.</p> <p></p> <p>Insert the SD card and click 'Proceed' to allow the installer to detect it.</p> <p></p> <p>\u26a0\ufe0f If a single SD card is inserted, the screen will display a large button. If multiple removable drives are detected, both SD cards and other drives will be listed.</p> <p>Select the desired removable drive to copy both <code>firmware.bin</code> and <code>firmware.bin.sig.</code> The first is the Krux firmware, and the second is a signature file that verifies the firmware\u2019s integrity and authenticity. </p> <p>Now you can compare the firmware's hash computed by installer with  the firmware's hash computed by the device. </p> <p></p> <p>\u26a0\ufe0f Once files are copied, remove the SD card from computer, connect to device and compare the hashes</p>"},{"location":"getting-started/installing/from-gui/usage/#wipe-device","title":"Wipe device","text":"<p>This is a two step process, Warning msg and Wipe process.</p>"},{"location":"getting-started/installing/from-gui/usage/#warning_1","title":"Warning","text":"<p>Before the wipe starts, it will show to you a message:</p> <p></p> <p>\u26a0\ufe0f  TIP: It's useful when your device is not working or for security reasons. To use Krux again, you'll need to re-flash the firmware.</p>"},{"location":"getting-started/installing/from-gui/usage/#wipe","title":"Wipe","text":"<p>Once the process starts, the screen will appear frozen and a spinner will keep moving. When it's done, you can scroll down you will see a <code>check</code> icon.</p> <p></p> <p>\u26a0\ufe0f  TIP: Do not unplug or poweroff your device or computer. Wait until the process finishes.</p>"},{"location":"getting-started/installing/from-gui/usage/#tips","title":"Tips","text":""},{"location":"getting-started/installing/from-gui/usage/#multilingual-support","title":"Multilingual support","text":"<p>Prefer a different language? Krux has support for multiple languages. Once at the start screen, go to <code>Settings</code>, followed by <code>Locale</code>, and select the locale you wish to use.</p>"},{"location":"getting-started/installing/from-gui/usage/#upgrade-via-microsd-card","title":"Upgrade via microSD card","text":"<p>Once you've installed the initial firmware on your device via USB, you can either continue updating the device by flashing or you can perform further upgrades via microSD card to keep the device airgapped.</p>"},{"location":"getting-started/installing/from-gui/verify-download/","title":"Verify","text":"<p>Before start using the GUI, it's strongly recommended to verify the authenticity of the krux-installer.SHA256.txt file. It attest the integrity of all variants (krux_installer_0.0.21_amd64.deb, krux_installer-0.0.21-1.x86_64.rpm, krux_installer_0.0.21_arm64.dmg, krux_installer_v0.0.21_Setup.exe).</p> <p>To do this, download two files:</p> <ul> <li><code>krux-installer.SHA256.txt</code>;</li> <li><code>krux-installer.SHA256.txt.sig</code>.</li> </ul>"},{"location":"getting-started/installing/from-gui/verify-download/#verify-the-authenticity","title":"Verify the authenticity","text":"<p>Linux/MacOS</p> <p>The next step is import the developer's key:</p> <pre><code>gpg --keyserver hkps://keys.openpgp.org --recv-keys B4281DDDFBBD207BFA4113138974C90299326322\n</code></pre> <p>Then, to verify yourself, run this:</p> <pre><code>gpg --verify krux-installer.SHA256.txt.sig\n</code></pre> <p>Windows</p> <ul> <li>You'll need have GPG installed;</li> <li>We recommend installing GPG4Win.</li> </ul> <p>After install, you can proceed with Linux/MacOS steps in the terminal.</p> <p>\u26a0\ufe0f  TIP: If the verification was successful, you may get a message similar to: <code>Good signature from \"qlrddev &lt;qlrddev@gmail.com&gt;\"</code>. Also, you can ignore a WARNING message if it says that the key isn't a trusted one (you need to do it manually).</p>"},{"location":"getting-started/installing/from-gui/verify-download/#verify-the-integrity","title":"Verify the integrity","text":"<p>After verify that the <code>krux-installer.SHA256.txt</code> is authentic, we can proceed with the integrity check in your <code>bash</code>/<code>zsh</code> terminal:</p> <p>Linux / MacOS</p> <pre><code>sha256sum --check krux-installer.SHA256.txt\n</code></pre> <p>Windows</p> <p>You can verify the integrity with this command in a <code>powershell</code> terminal:</p> <pre><code>$exe = '.\\krux_installer_v0.0.21_Setup.exe'\n$file = Split-Path $exe -Leaf\n\n(Get-FileHash $exe -Algorithm SHA256).Hash -eq\n(Select-String $file '.\\krux-installer.SHA256.txt').Line.Split()[0].ToUpper()\n</code></pre> <p>\ud83d\udee1\ufe0f  TIP: If you followed the authenticity/integrity checks steps presented, you already have the assurance that the software is from a verified and genuine software publisher. This will also help establish a chain of trust when you perform the firmware verification step before flashing.</p>"},{"location":"getting-started/installing/from-gui/windows/","title":"Download assets","text":"<ul> <li><code>krux_installer_v0.0.21_Setup.exe</code></li> </ul>"},{"location":"getting-started/installing/from-gui/windows/#install","title":"Install","text":"<p>Execute the <code>krux_installer_v0.0.21_Setup.exe</code>. You'll be faced with a blue window saying \"Windows protected your PC\". This occurs because we don't have a code signing certificate:</p> <p></p> <p>Follow the installer's instructions to complete the installation. At the end, click on  \"Create desktop icon\":</p>"},{"location":"getting-started/installing/from-gui/windows/#after-install","title":"After install","text":"<p>Once done, you will use Krux-Installer GUI to perform the firmware installation. </p>"},{"location":"getting-started/templates/templates/","title":"Templates","text":"<p>Here we offer a few templates to transcribe QR codes, Tinyseed or Binary Grid backups.</p>"},{"location":"getting-started/templates/templates/#qr-code-templates","title":"QR Code Templates","text":"<p>You can manually copy compact SeedQR codes or place a proper sized template over the device screen. Protect the template backside with a transparent tape so you won't bleed ink through the paper to your device's screen. Then, using a marker, paint the QR code.</p>"},{"location":"getting-started/templates/templates/#v1-21x21","title":"V1 - 21x21","text":"<p>SVG: Dots, Lines, Dots and Lines</p>"},{"location":"getting-started/templates/templates/#v2-25x25","title":"V2 - 25x25","text":"<p>SVG: Dots, Lines, Dots and Lines</p>"},{"location":"getting-started/templates/templates/#v3-29x29","title":"V3 - 29x29","text":"<p>SVG: Dots, Lines, Dots and Lines</p>"},{"location":"getting-started/templates/templates/#v4-33x33","title":"V4 - 33x33","text":"<p>SVG: Dots, Lines, Dots and Lines</p>"},{"location":"getting-started/templates/templates/#v5-37x37","title":"V5 - 37x37","text":"<p>SVG: Dots, Lines, Dots and Lines</p>"},{"location":"getting-started/templates/templates/#tinyseed-templates","title":"Tinyseed Templates","text":"<p>Tinyseed background of blank templates to be manually filled.</p> <p> </p> <p> </p> <p> </p>"},{"location":"getting-started/templates/templates/#binary-grid-templates","title":"Binary Grid Templates","text":"<p>Binary Grid labeled and and \"stealth\" clean templates.</p> <p> </p> <p> </p> <p>Binary Grid svg source</p> <p>Binary Grid Clean svg source</p>"},{"location":"getting-started/templates/templates/#edit-templates","title":"Edit Templates","text":"<p>To edit the source file (.svg) it is recommended to use Inkscape and set it to use mm unit. \"Unscaled models\" from QR code templates have the 21x21 or 25x25mm size for 12 or 24 respectively, this way making them easier to edit.</p>"},{"location":"getting-started/usage/generating-a-mnemonic/","title":"Generating a Mnemonic","text":"<p>Krux supports creating 12 and 24-word BIP39 mnemonic seed phrases using random bits, also known as entropy. Generating true entropy is challenging, especially for an embedded device, so we recommend outsourcing entropy generation using dice rolls. However, it is also possible to randomly pick words (e.g., SeedPicker) or use the camera as a source of entropy to quickly create a mnemonic.</p> <p>At the start screen, select New Mnemonic, and choose between camera, words, rolls of a D6 (standard six-sided die), or a D20 (20-sided die).</p> <p> </p>"},{"location":"getting-started/usage/generating-a-mnemonic/#camera","title":"Camera","text":"<p>(Experimental!) Choose between 12, 24 words or double mnemonic, then take a random picture and Krux will generate a mnemonic from the hash of the image bytes.</p> <p> </p>"},{"location":"getting-started/usage/generating-a-mnemonic/#image-entropy-quality-estimation","title":"Image Entropy Quality Estimation","text":"<p>During image capture, entropy quality estimation is displayed to assist you in obtaining a quality image source for your key. After the snapshot is taken, Shannon's entropy and pixel deviation indices are presented. Minimum thresholds are established to prevent the use of poor-quality images with low entropy for key generation.</p> <p>Note: These values \u200b\u200bserve only as indicators or estimations of the quality of entropy, but are not absolute values \u200b\u200bof entropy in a cryptographic context.</p>"},{"location":"getting-started/usage/generating-a-mnemonic/#double-mnemonic","title":"Double mnemonic","text":"<p>It is the combination of two 12-word mnemonics that also forms a valid 24-word BIP39 mnemonic. This is achieved by using the first 16 bytes (128 bits) of the image's entropy to generate the first 12-word, then using the next 16 bytes to generate the second 12-word and checking if these two 12-word together forms a valid 24-word, if not, we iterate over the second 12-word incrementing its entropy bytes until the two 12-word forms a valid 24-word.</p> <p>Double Mnemonic was first defined by Stepan Snigirev in his Double Mnemonic Generator. It can be used for plausible deniability, or, as Stepan stated, to have fun and confuse everyone.</p>"},{"location":"getting-started/usage/generating-a-mnemonic/#words","title":"Words","text":"<p>Print the BIP39 word list in 3D or on paper, then cut out the words and place them in a bucket. Manually draw 11 or 23 words from the bucket. For the final word, Krux will assist you in picking a valid 12th or 24th word by adjusting its smart keypad to only allow typing words with a valid checksum. Alternatively, you can leave it empty, and Krux will select a final, valid checksum word for you.</p>"},{"location":"getting-started/usage/generating-a-mnemonic/#dice-rolls","title":"Dice Rolls","text":""},{"location":"getting-started/usage/generating-a-mnemonic/#via-d6","title":"Via D6","text":"<p>Choose between 12 or 24 words. The entropy in a single roll of a D6 is 2.585 bits ( log<sub>2</sub>(6) ); therefore a minimum of 50 rolls is required for 128 bits of entropy, enough to generate a 12-word mnemonic. For 24 words, a minimum of 99 rolls is required for 256 bits of entropy.</p> <p> </p>"},{"location":"getting-started/usage/generating-a-mnemonic/#via-d20","title":"Via D20","text":"<p>The entropy in a single roll of a D20 is 4.322 bits ( log<sub>2</sub>(20) ); therefore a minimum of 30 rolls is required to generate a 12-word mnemonic and 60 rolls to generate a 24-word mnemonic.</p> <p> </p>"},{"location":"getting-started/usage/generating-a-mnemonic/#dice-rolls-entropy-quality-estimation","title":"Dice Rolls Entropy Quality Estimation","text":"<p>As you enter your dice rolls, you'll see two progress bars fill up. The top progress bar shows how many rolls you've entered compared to the minimum required. The bottom progress bar shows the real-time calculated Shannon's entropy compared to the minimum required (128 bits for 12 words and 256 bits for 24 words). When the Shannon's entropy estimation reaches the recommended level, the progress bar will be full, and its frame will change color. If you've reached the minimum number of rolls but the entropy estimation is still below the recommended level, a warning will appear suggesting that you add more rolls to increase the entropy.</p> <p>Note: Similar to image entropy quality estimation, dice rolls Shannon's entropy serves as an indicator and should not be considered an absolute measure of cryptographic entropy.</p> <p>Learn more about Krux Entropy Quality Estimation.</p>"},{"location":"getting-started/usage/generating-a-mnemonic/#stats-for-nerds","title":"Stats for Nerds","text":"<p>A low Shannon's entropy value could suggest that your dice are biased or that there's a problem with how you're gathering entropy. To investigate further, examine the \"Stats for Nerds\" section to check the distribution of your rolls and look for any abnormalities.</p> <p> </p>"},{"location":"getting-started/usage/generating-a-mnemonic/#optional-edit-mnemonic","title":"(Optional) Edit Mnemonic","text":"<p>After sufficient entropy is given, you can manually add custom entropy by editing some of the words. Simply touch or navigate to the word you want to change and replace it. Edited words will be highlighted, and the final word will automatically update to ensure a valid checksum. However, proceed with caution, modifying words can negatively impact the natural entropy previously captured.</p> <p>On the next screen, you will be loading a wallet. You can read more about this in Loading a Mnemonic -&gt; Confirm Wallet Attributes.</p>"},{"location":"getting-started/usage/generating-a-mnemonic/#how-entropy-works-in-krux","title":"How Entropy Works in Krux","text":"<p>For dice rolls, Krux keeps track of every roll you enter and displays the cumulative string of outcomes after each roll. </p> <p>When you have entered your final roll, Krux will hash this string using SHA256 and output the resulting hash to the screen so that you can verify it for yourself.</p> <p>In case a camera snapshot is used as a source, the image bytes, which contain pixels data in RGB565 format, will be hashed in the same way as the dice rolls.</p> <p> </p> <p>Krux then takes this hash, runs <code>unhexlify</code> on it to encode it as bytes, and deterministically converts it into a mnemonic according to the BIP39 Reference Implementation.</p> <p>Note: For 12-word mnemonics, only the first half of the SHA256 hash is used (128 bits), while 24-word mnemonics use the full hash (256 bits).</p>"},{"location":"getting-started/usage/generating-a-mnemonic/#how-to-verify","title":"How to Verify","text":"<p>Don't trust, verify. We encourage you not to trust any claim you cannot verify yourself. Therefore, there are wallets that use compatible algorithms to calculate the entropy derived from dice rolls. You can use the SeedSigner or Coldcard hardware wallets, or even the Bitcoiner Guide website, they share the same logic that Krux uses and will give the same mnemonic for the dice roll method.</p>"},{"location":"getting-started/usage/","title":"Basic Usage","text":"<p>After successfully installing the firmware, you will see this screen with the following options.</p> <p> </p>"},{"location":"getting-started/usage/#load-mnemonic","title":"Load Mnemonic","text":"<p>Load your 12 or 24-word BIP39 mnemonic. For more information, see Loading a Mnemonic.</p>"},{"location":"getting-started/usage/#new-mnemonic","title":"New Mnemonic","text":"<p>Create your 12 or 24-word BIP39 mnemonic. For more information, see Generating a Mnemonic.</p>"},{"location":"getting-started/usage/#settings","title":"Settings","text":"<p>Configure your device according to your preferences, change the language, appearance, and more. See all options on the Settings page.</p>"},{"location":"getting-started/usage/#tools","title":"Tools","text":"<p>Useful tools are available, such as an SD card explorer or a QR code creator. See them all on the Tools page.</p> <p> </p>"},{"location":"getting-started/usage/#about","title":"About","text":"<p>A simple screen showing the currently installed firmware and its version.</p>"},{"location":"getting-started/usage/#shutdown-reboot","title":"Shutdown / Reboot","text":"<p>If your device has battery, you can turn it off using this option.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/","title":"Loading a Mnemonic","text":"<p>Once you have either a 12 or 24-word BIP39 mnemonic, choose <code>Load Mnemonic</code> on Krux's start menu (aka login menu), and choose an input method:</p> <p> </p>"},{"location":"getting-started/usage/loading-a-mnemonic/#input-methods","title":"Input Methods","text":""},{"location":"getting-started/usage/loading-a-mnemonic/#via-camera","title":"Via Camera","text":"<p>You can choose to use the camera to scan a <code>QR code</code>, <code>Tinyseed</code>, <code>OneKey KeyTag</code> or a <code>Binary Grid</code>. Learn more about these metal backups here.</p> <p>Tip: You can hold down the <code>ENTER</code> button of the M5StickV, Maix Amigo or WonderMV to turn on their LED light to potentially increase visibility. All cameras have zoom and anti-glare mode, use anti-glare to capture images from high brightness screens or with incident light. Enable/disable zoom/anti-glare by pressing <code>PAGE</code> button while scanning.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#qr-code","title":"QR Code","text":"<p>It's unpleasant having to manually enter 12 or 24 words every time you want to use Krux. To remedy this you can instead use the device's camera to read a QR code containing the words. Krux will decode QR codes of four types:</p> <ul> <li>Plain text QR: The mnemonic words encoded as text, with words separated by spaces.</li> <li>SeedQR: Basically, it is the mnemonic words of the respective BIP39 numbers concatenated, encoded as text.</li> <li>Compact SeedQR: Basically, it is the mnemonic words bits concatenated as bytes.</li> <li>Encrypted Mnemonic: A specification created by Krux that encrypts the mnemonic words bits and adds some information about the encryption used.</li> </ul> <p>After opening a wallet via one of the methods available you can use Krux to backup the mnemonic as QR code, transcribe them to paper or metal using the transcription helpers or attach a thermal printer to your Krux and print out the mnemonic as QR. Check out the printing section for more information. You can also use an offline QR code generator for this (ideally on an airgapped device).</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#tinyseed-onekey-keytag-or-binary-grid","title":"Tinyseed, OneKey KeyTag or Binary Grid","text":"<p>Tinyseed, Onekey KeyTag and others directly encode a seed as binary, allowing for a very compact mnemonic storage. Krux devices have machine vision capabilities that allow users to scan these metal plates and instantly load mnemonics engraved on them (this feature is not available in Krux Mobile Android app).</p> <p>To ensure a proper scan, place the backup plate over a black background and fill in the punched areas with black to enhance contrast. Alternatively, you can scan a thermally printed version or a completed template. You can view some examples of encoded mnemonics here, and explore our available transcription templates here.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#via-manual-input","title":"Via Manual Input","text":"<p>Manually type <code>Words</code>, <code>Word Numbers</code>, <code>Tinyseed</code> (toggle the bits or punches) or <code>Stackbit 1248</code>.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#words","title":"Words","text":"<p>Enter each word of your BIP39 mnemonic one at a time. Krux will disable impossible-to-reach letters as you type and will attempt to autocomplete your words to speed up the process.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#word-numbers","title":"Word Numbers","text":""},{"location":"getting-started/usage/loading-a-mnemonic/#decimal","title":"Decimal","text":"<p>Enter each word of your BIP39 mnemonic as a number (1-2048) one at a time. You can use this list for reference.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#hexadecimal-and-octal","title":"Hexadecimal and Octal","text":"<p>You can also enter your BIP39 mnemonic word's numbers (1-2048) in hexadecimal format, with values ranging from 0x1 to 0x800, or in octal format, with values ranging from 01 to 04000. This is useful with some metal plate backups that uses those formats.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#tinyseed-bits","title":"Tinyseed (Bits)","text":"<p>Enter the BIP39 mnemonic word's numbers (1-2048) in binary format, toggling necessary bits to recreate each of the word's respective number. The last word will have checksum bits dynamically toggled while you fill the bits.</p> <p>Tip: You can use this screen to generate a mnemonic by flipping a coin:</p> <ul> <li>Flip a coin, if it is heads, mark the first space (value 1) of the word, if it is tails do nothing. Repeat this step for each space up to 1024 (if you flip 11 tails in a row, just leave the 2048 square marked).</li> <li>The last word has the checksum, you will do as you did with the other words, the only difference is that you cannot set some spaces, they are calculated automatically. For 12 words you will flip the coin only 7 times, for spaces 16, 32, 64, 128, 256, 512 and 1024. For 24 words you will flip the coin only 3 times, for spaces 256, 512 and 1024.</li> </ul>"},{"location":"getting-started/usage/loading-a-mnemonic/#stackbit-1248","title":"Stackbit 1248","text":"<p>Enter the BIP39 mnemonic word's numbers (1-2048) using the Stackbit 1248 metal plate backup method, where each of the four digits of the word's number is a sum of the numbers marked (punched) 1, 2, 4, or 8. For example, to enter the word \"oyster\", number 1268, you must punch (1)(2)(2,4)(8).</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#from-storage","title":"From Storage","text":"<p>You can also retrieve encrypted mnemonics previously stored on device's internal memory or external (SD card). To load them you'll have to enter the same key you used to encrypt them.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#confirm-wallet-setup","title":"Confirm Wallet Setup","text":""},{"location":"getting-started/usage/loading-a-mnemonic/#confirm-mnemonic-words","title":"Confirm Mnemonic Words","text":"<p>Once you have entered your mnemonic, you will be presented with the full list of words to confirm. A 12 word has only 4 checksum bits, so it has a 1 in 16 chance (6,25%) of still being valid even if you mistype a word. A 24 word phrase has 8 checksum bits, so it only has 1 in 256 chance (~0,4%) of still being valid if you mistype a word.</p> <p>  If you see an asterisk (<code>*</code>) in the header, it means this is a double mnemonic.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#optional-edit-mnemonic","title":"(Optional) Edit Mnemonic","text":"<p>If you make a mistake while loading a mnemonic, you can easily edit it. Simply touch or navigate to the word you want to change and replace it. Edited words will be highlighted. If the final word contains an invalid checksum, it will appear in red. If your checksum word is red, please review your mnemonic carefully, as there may be an error.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#confirm-wallet-attributes","title":"Confirm Wallet Attributes","text":"<p>After confirming your mnemonic, a screen with an information box at the top with the wallet's attributes is shown. If they are as expected, just press <code>Load Wallet</code>. If you need to change something you may customize the wallet by setting a <code>Passphrase</code> or using the <code>Customize</code> button.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#the-attributes","title":"The Attributes:","text":""},{"location":"getting-started/usage/loading-a-mnemonic/#fingerprint","title":"Fingerprint","text":"<ul> <li> <code>73c5da0a</code>: The BIP32 master wallet's fingerprint helps you make sure you entered the correct mnemonic and passphrase (optional) and will load the expected wallet. The fingerprint is the best checksum you can have, it's good to note it down.</li> </ul>"},{"location":"getting-started/usage/loading-a-mnemonic/#network","title":"Network","text":"<ul> <li><code>Mainnet</code>: Check if you are loading a <code>Testnet</code> or <code>Mainnet</code> wallet.</li> </ul>"},{"location":"getting-started/usage/loading-a-mnemonic/#policy-type","title":"Policy Type","text":"<ul> <li>Check the wallet's policy type: <code>Single-sig</code>, <code>Multisig</code>, <code>Miniscript</code>, or <code>TR Miniscript</code> (Taproot).</li> </ul>"},{"location":"getting-started/usage/loading-a-mnemonic/#derivation-path","title":"Derivation Path","text":"<ul> <li> <p> <code>m/84h/0h/0h</code>: The derivation path is a sequence of numbers, or \"nodes\", that define the script type, network, and account index of your wallet.</p> <ul> <li>Script Type <code>84h</code>: The first number defines the script type. The default is <code>84h</code>, corresponding to a Native Segwit wallet. Other values include:<ul> <li><code>44h</code> for Legacy</li> <li><code>49h</code> for Nested Segwit</li> <li><code>86h</code> for Taproot</li> <li><code>48h</code> for Multisig</li> </ul> </li> <li>Network <code>0h</code>: The second number defines the network:<ul> <li><code>0h</code> for Mainnet</li> <li><code>1h</code> for Testnet</li> </ul> </li> <li>Account Index <code>0h</code>: The third number is the account index, with <code>0h</code> being the default.</li> <li>Additional: For multisig wallets, a fourth node with the value <code>2h</code> is added to the derivation path.</li> </ul> <p>Default Miniscript derivation path is the same as for multisig: <code>m/48'/0h/0h/2h</code>, but they can be fully customized</p> </li> </ul>"},{"location":"getting-started/usage/loading-a-mnemonic/#passphrase","title":"Passphrase","text":"<ul> <li><code>No Passphrase</code>: Informs if the wallet has a passphrase. Adding or changing the passphrase results in a completely different wallet and fingerprint.</li> </ul>"},{"location":"getting-started/usage/loading-a-mnemonic/#customize-wallet","title":"Customize Wallet","text":"<p>It is possible to change any of the wallet's attributes (it will be possible to change them later too, after loading). To load it faster next time, some default wallet attributes can be set in settings, they are: <code>Network</code>, <code>Policy Type</code> and <code>Script Type</code>.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#passphrase_1","title":"Passphrase","text":"<p>You can type or scan a BIP39 passphrase. When typing, swipe left  or right  to change keypads if your device has a touchscreen. You can also hold the button <code>PAGE</code> or <code>PREVIOUS</code> when navigating among letters while typing text to fast forward or backward. For scanning, you can also create a QR code from your offline passphrase using the Datum tool.</p>"},{"location":"getting-started/usage/loading-a-mnemonic/#customize","title":"Customize","text":"<p>This button opens a screen to change the <code>Network</code>, <code>Policy Type</code>, <code>Script Type</code>, and <code>Account</code> of the wallet. If <code>Policy Type</code> is Miniscript, you will be able to enter a custom derivation path.</p> <p>When everything looks good, press <code>Load Wallet</code>and you will go to the main menu...</p>"},{"location":"getting-started/usage/navigating-the-main-menu/","title":"Navigating the Main Menu","text":"<p>After entering your mnemonic, and loading a wallet, you will find yourself on Krux's main menu. Below is a breakdown of the entries available:</p> <p> </p>"},{"location":"getting-started/usage/navigating-the-main-menu/#backup-mnemonic","title":"Backup Mnemonic","text":"<p>This will open a new submenu with different types of backups. <code>QR Code</code> based, <code>Encrypted</code> and <code>Other Formats</code>.</p> <p>If you set a printer, it will also give the option to print them!</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#qr-code","title":"QR Code","text":"<ul> <li>Plaintext QR</li> </ul> <p>Generate a QR containing the mnemonic words as regular text, where words are separated by spaces. Like any QR code, it can be printed after setting up the printer driver.</p> <ul> <li>Compact SeedQR</li> </ul> <p> </p> <p>A QR code is created from a binary representation of mnemonic words. Format created by SeedSigner, more info here.</p> <ul> <li>SeedQR</li> </ul> <p> </p> <p>Words are converted to their BIP39 numeric indexes, those numbers are then concatenated as a string and finally converted to a QR code. Format created by SeedSigner, more info here.</p> <ul> <li>Encrypted QR Code</li> </ul> <p>This option converts the encrypted mnemonic into a QR code. Enter an encryption key and, optionally, a custom ID. When you scan this QR code through Load Mnemonic -&gt; Via Camera -&gt; QR Code, you will be prompted to enter the decryption key to load the mnemonic stored in it. Like any QR code, it can be printed after setting up the printer driver.</p> <p>Transcribing QR Codes</p> <p>Please refer to Transcribing QR Codes for details on transcription modes and helper tools.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#encrypted","title":"Encrypted","text":"<p>This feature allows you to back up your mnemonic by encrypting it and storing it on the device's flash memory, on an SD card, or in QR code format. You can customize the encryption method and parameters in the settings.</p> <p>When using any of the encryption methods, you will be prompted to enter an encryption key. This key can be provided in text or QR code format. Additionally, you have the option to set a custom ID for easier management of your mnemonics. If a custom ID is not specified, the current loaded wallet fingerprint will be used.</p> <p>Note: The stored encrypted mnemonic is protected only by the key you defined to encrypt it. Also, it is advisable not to rely solely on digital methods for backup. Read the considerations section on Krux Mnemonics Encryption.</p> <ul> <li>Store on Flash</li> </ul> <p>This option stores the encrypted mnemonic in the device's flash memory. You can decrypt and load it later through the Load Mnemonic -&gt; From Storage.</p> <ul> <li>Store on SD Card</li> </ul> <p>If an SD card is available, this option stores the encrypted mnemonic on it. You can decrypt and load it later through the Load Mnemonic -&gt; From Storage.</p> <ul> <li>Encrypted QR Code It's another path for the same functionality present on QR Code backups, described above.</li> </ul>"},{"location":"getting-started/usage/navigating-the-main-menu/#other-formats","title":"Other Formats","text":"<ul> <li>Words</li> </ul> <p>Display the BIP39 mnemonic words as text so you can write them down.</p> <ul> <li>Numbers</li> </ul> <p> </p> <p>Display the BIP39 mnemonic word numbers (1-2048) in decimal, hex, or octal format.</p> <ul> <li>Stackbit 1248</li> </ul> <p> </p> <p>This metal backup format represents the BIP39 mnemonic word's numbers (1-2048). Each of the four digits is converted to a sum of 1, 2, 4 or 8. This option does not print even if a printer driver is set.</p> <ul> <li>Tinyseed</li> </ul> <p> </p> <p>This metal backup format represents the BIP39 mnemonic word's numbers (1-2048) in binary format on a metal plate, where the 1's are marked (punched) and the 0's are left intact. You can also print your mnemonic in this format after setting up the thermal printer driver.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#extended-public-key","title":"Extended Public Key","text":"<p>A menu will be presented with options to display your master extended public key (xpub) as text and as a QR code. Depending on the script type or whether a single-sig or multisig wallet was loaded, the options shown will be xpub, ypub, zpub or Zpub. When displayed as text, the extended public key can be stored on an SD card if available. If you choose to export a QR code, you can not only scan it but also save it as an image on an SD card or be printed, after setting up the printer driver.</p> <p> </p> <p>All QR codes will contain key origin information in key expressions. If your wallet coordinator cannot parse this information, it will not be able to import the wallet's fingerprint. As a result, Krux will not perform important verifications when signing PSBT transactions created by this wallet coordinator, unless you manually add the fingerprint in the coordinator.</p> <p>Always prefer to import extended public keys directly from Krux when setting up a wallet coordinator instead of copying it (or parts of it) from other sources.</p> <p>Some coordinators are phasing out support for variants like ypub and zpub in favor of xpubs that include key origin data. We therefore recommend using xpub only.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#wallet","title":"Wallet","text":"<p>Here you can load, view and save <code>Wallet Descriptor</code>, you can also customize the wallet by setting a <code>Passphrase</code> or change other attribute using the <code>Customize</code> button. It is possible to derive <code>BIP85</code> entropy for <code>BIP39 Mnemonic</code> and <code>Base64 Password</code> as well.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#wallet-descriptor","title":"Wallet Descriptor","text":"<p>A Bitcoin Wallet Output Script Descriptor (aka wallet descriptors) encodes essential details such as:</p> <ul> <li>Script: Specifies the type of script (P2PKH, P2SH, P2WPKH, P2TR, ..). For miniscript, it outlines advanced spending policies and conditions.</li> <li>Origin Info: For each key, it includes the corresponding master fingerprint and derivation path that was used to derive it.</li> <li>Extended Public Keys: Contains one or more extended public keys (xpub, ypub, zpub, ..), each associated with its own origin information.</li> </ul> <p>Output descriptors standardize wallet address generation, ensuring accurate wallet restoration from backups and compatibility across different apps.</p> <p>For multisig and miniscript, loading a wallet descriptor is essential to verify addresses and PSBT validations. For single-sig wallets, it remains optional and serves as a redundancy check of the coordinator's wallet attributes.</p> <p> </p> <p>When you select the <code>Wallet Descriptor</code> option for the first time, you will be prompted to load via QR code or SD card. After loading, a preview of the descriptor attributes will be displayed for confirmation. We shown each key\u2019s fingerprint, derivation path, and abbreviated XPUB highlighted with a different color.</p> <p>Miniscript Descriptors present an indented view of the miniscript after the keys. When Taproot is used, Krux checks if the internal key is \"provably unspendable\", meaning funds can only be moved via Tap tree scripts, in which case the internal key is displayed in a disabled color.</p> <p> </p> <p>Re-access the \"Wallet Descriptor\" option after loading your wallet to view its name and a QR code containing the originally loaded data. If an SD card is inserted, you can save the descriptor for future use without a coordinator's assistance. Like any QR code, it can be printed after setting up the printer driver.</p> <p>Krux also allows you to verify a descriptor's receive and change addresses without the need to load private keys. Simply turn on your Krux, access Tools -&gt; Descriptor Addresses, and load a trusted descriptor from a QR code or SD card.</p> <p>Please note that if you customize the wallet parameters or restart the device, the descriptor will be unloaded, and you may need to load it again to check addresses.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#passphrase","title":"Passphrase","text":"<p>If you forgot to load a passphrase while loading your wallet, or if you use multiple passphrases with the same mnemonic, you can add, replace, or remove a passphrase here. Simply choose between typing or scanning it.</p> <p>To remove a passphrase, select <code>Type BIP39 Passphrase</code>, leave the field blank, and press <code>Go</code>.</p> <p>Don't forget to verify the resulting fingerprint in the status bar to ensure you've loaded the correct key.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#customize","title":"Customize","text":"<p>Here you are presented with the same customization options that you have when loading. You can change <code>Network</code>, <code>Policy Type</code>, <code>Script Type</code>, and <code>Account</code>. On loading a mnemonic page we already detail the wallet's attributes.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#bip85","title":"BIP85","text":"<p>Bitcoin BIP85 (aka Deterministic Entropy From BIP32 Keychains) allows for the generation of deterministic entropy using a BIP32 master key. This entropy can then be used to create various cryptographic keys and mnemonics (e.g., BIP39 seed phrases). BIP85 ensures that all derived keys and mnemonics are deterministic and reproducible, meaning they can be recreated from the same master key. This feature is useful for securely managing multiple child keys from a single master key without the need to store each one separately.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#bip39-mnemonic","title":"BIP39 Mnemonic","text":"<p>Choose between 12 or 24 words, then type the desired index to export a child mnemonic. After being presented with the new mnemonic, you can choose to load and use it right away.</p> <p>Notice: Any passphrase from the parent mnemonic will be removed when loading a BIP85 child mnemonic.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#base64-password","title":"Base64 Password","text":"<p>To create a Base64 password, which can be used in a variety of logins, from email to social media accounts, choose an index and then a length of at least 20 characters. The resulting password will be displayed on the screen and can also be exported to an SD Card or as a QR code.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#mnemonic-xor","title":"Mnemonic XOR","text":"<p>Mnemonic XOR enables the combination of two or more mnemonics by applying an XOR (exclusive OR) operation to their entropy bytes, resulting in a new mnemonic. This functionality can be used to split a mnemonic into multiple parts (or \"shares\") or to merge existing ones.</p> <p>For detailed instructions on combining, splitting, and recovering mnemonics using XOR, see Mnemonic XOR.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#address","title":"Address","text":"<p>Scan, list, export or print your wallet addresses.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#scan-address","title":"Scan Address","text":"<p>This option turns on the camera and allows you to scan in a QR code of an address. Upon scanning, it will render its QR code back to the display along with the address below.</p> <p>Tip: You could use this feature to scan the address of someone you want to send coins to and display the QR back to your wallet coordinator rather than copy-pasting an address. Like any QR code, it can be printed after setting up the printer driver.</p> <p>After this, you will be asked if you want to check that the address belongs to your wallet. If you confirm, it will exhaustively search through addresses derived from your wallet find a match. This is an extra security check to verify that the address generated by the wallet coordinator is authentic and belongs to your wallet.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#list-addresses","title":"List Addresses","text":"<p>List your wallet receiving or change addresses, you can select an arbitrary address to show your QR code and print if you want.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#export-addresses","title":"Export Addresses","text":"<p>Export your wallet receiving or change addresses starting from a selected index and quantity to a CSV file on your SD card.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#sign","title":"Sign","text":"<p>Here you can choose to sign a PSBT or a Message. You can load both by scanning QR codes or selecting a file from an SD card.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#psbt","title":"PSBT","text":"<p>To sign a Bitcoin PSBT, you have the following options:</p> <ul> <li><code>Load from camera</code>: Use the camera to scan an animated QR code of a PSBT generated by your wallet coordinator software. If you have any issues, see Troubleshooting.</li> <li><code>Load from SD Card</code>: Load a PSBT file from your SD card.</li> </ul> <p> </p> <p>Upon loading the unsigned PSBT, you will be presented with a preview of the transaction, showing:</p> <ul> <li>How many Inputs (UTXO) are involved and the amount of BTC.</li> <li>How many Spend (addresses that don't belong to you wallet) and the amount of BTC.</li> <li>How many Self-transfer or Change (addresses that belong to your wallet) and the amount of BTC.</li> <li>How much Fee is being paid, the percentage relative to what is sent and an approximation in sat/vB (not available if <code>Policy Type</code> is Miniscript).</li> </ul> <p>Amounts are displayed according to your locale and the International Bureau of Weights and Measures, while still adhering to the concept of the Satcomma standard format.</p> <p> </p> <p>You can then choose to review the PSBT or proceed with one of two signing options:</p> <ul> <li><code>Review</code>: Preview the PSBT again - including inputs, outputs (send, self-transfer, or change), and fee.</li> <li><code>Sign to QR code</code>: Display the signed PSBT as an animated QR code, ready to be scanned by your coordinator wallet.</li> <li><code>Sign to SD card</code>: Save the signed PSBT file to your SD card for later import into your coordinator wallet.</li> </ul> <p>Tip: If a thermal printer is attached to your device, you can also print the PSBT QR codes for further processing.</p>"},{"location":"getting-started/usage/navigating-the-main-menu/#message","title":"Message","text":"<p>Similar to PSBTs, Krux can load, sign, and export signatures for messages. This feature allows you to attest not only to the ownership of the messages themselves but also to the ownership of Bitcoin addresses and the authorship of documents and files.</p> <ul> <li>Standard Messages and Files</li> </ul> <p> </p> <p>You can scan or load a file from an SD card, the content can be plaintext or the SHA-256 hash of a message. Upon loading, you will be shown a preview of the message's SHA-256 hash for confirmation before signing.</p> <p>If you confirm, a signature will be generated, and you will see a base64-encoded version of it. You can then choose to export it as a QR code or save it to an SD card. If a thermal printer is attached, you can also print the QR code.</p> <p>Following this, you will see and be allowed to export your raw (master) public key in hexadecimal form, which can be used by others to verify your signature. If a thermal printer is attached, you can also print this QR code.</p> <p>This feature is used to sign Krux releases, airgapped, using a Krux device.</p> <ul> <li>Messages at Address</li> </ul> <p> </p> <p>Coordinators like Sparrow and Specter offer the possibility to sign messages at a Bitcoin receive address, allowing you to attest ownership of that address. Krux will detect if the message is of this type and present a similar workflow for signing. The main difference is that the address will be displayed along with the raw message, and since the message is signed with a derived address instead of the master public key, Krux won't offer the option to export the raw public key after the signature.</p>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/","title":"Setting a Coordinator and Signing","text":"<p>Once you've generated a mnemonic, securely backed it up, and successfully tested the recovery process, you\u2019re ready to set up a coordinator.</p> <p>Krux works with:</p> <ul> <li>Sparrow Wallet (desktop)</li> <li>Specter Desktop (desktop)</li> <li>Liana (desktop)</li> <li>Bitcoin Safe (desktop)</li> <li>Nunchuk (mobile)</li> <li>BlueWallet (mobile)</li> <li>Bitcoin Keeper (mobile)</li> <li>BULL Wallet (mobile)</li> </ul>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#step-1-install-the-coordinator-wallet","title":"Step 1: Install the Coordinator Wallet","text":"<p>Download and install the appropriate version of your chosen coordinator wallet for your device and operating system.</p>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#step-2-create-a-new-wallet-with-krux-as-a-signer","title":"Step 2: Create a New Wallet with Krux as a Signer","text":"<p>Depending on the coordinator, the steps to add Krux as a signer may vary slightly:</p> <ul> <li>Specter and Nunchuk Single-sig: Add Krux key, then create a wallet that uses it.</li> <li>Specter and Nunchuk Multisig: Add Krux key, add other keys, then create a wallet that uses them.</li> <li>Sparrow, Liana, Bitcoin Safe and BlueWallet: Create a wallet (or vault in Blue Wallet) and add key(s) during setup.</li> <li>Bitcoin Keeper: Add Wallet -&gt; Create Wallet, select single-key or multi-key, and add key(s). Or add key(s), then Add Wallet -&gt; Create Wallet and select that key(s).</li> </ul> <ol> <li> <p>Load a mnemonic and wallet in Krux.</p> <p> </p> </li> <li> <p>On your coordinator, select \"Krux\" if it's listed among the available signer devices. If not, choose \"Other\" or a QR code-compatible signer such as \"SeedSigner\". Since Krux supports various QR formats, other available options may also be compatible.</p> </li> <li> <p>When prompted by your coordinator to import signer's public key, access the <code>Extended Public Key</code> on Krux.</p> <p> </p> </li> <li> <p>Export an XPUB (or YPUB, ZPUB, .., based on the script type) as a QR code.</p> <p> </p> </li> <li> <p>Scan this QR code with your coordinator.</p> </li> <li>Ensure the coordinator\u2019s wallet attributes (policy type, script type, fingerprint, and derivation) match those in Krux.</li> </ol> <p>Alternatively, you can export the extended public keys as files to an SD card. Instead of displaying them as QR codes, select the <code>XPUB - Text</code> option, then choose <code>Save to SD card</code>.</p> <p> </p>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#step-3-load-and-backup-wallet-descriptor-multisig-only","title":"Step 3: Load and Backup Wallet Descriptor (Multisig Only)","text":"<ol> <li>In your coordinator, export the wallet descriptor containing information about the wallet and all cosigners:<ul> <li>Sparrow: \"Descriptor\"</li> <li>Specter: \"Export Wallet\"</li> <li>Liana: \"Wallet Descriptor\"</li> <li>Bitcoin Safe: \"Register multisig on signers\" on step 6 or \"Wallet Descriptor\"</li> <li>Nunchuk: \"Export Wallet Configuration\"</li> <li>BlueWallet: \"Export Coordination Setup\"</li> <li>Bitcoin Keeper: \"Wallet configuration file\"</li> </ul> </li> <li>Export the descriptor as a QR code or file.</li> <li>On Krux, go to Wallet -&gt; Wallet Descriptor to scan the descriptor QR code or load it via SD card.</li> </ol> <ol> <li> <p>If you access Wallet -&gt; Wallet Descriptor again, you will be able to:</p> <ul> <li>Check the wallet cosigners.</li> <li>Save the descriptor on an SD card (useful if you initially loaded it from QR codes).</li> </ul> <p>Tip: Having a backup of the wallet descriptor is essential for recovering your wallet.</p> </li> </ol>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#step-4-verify-addresses","title":"Step 4: Verify Addresses","text":"<p>For single-sig or multisig (after loading a descriptor):</p> <ul> <li>Go to <code>Address</code> on Krux.</li> <li>List <code>Receive Addresses</code> and <code>Change Addresses</code> or use <code>Scan Address</code> to verify if addresses from your coordinator are matched by Krux.</li> </ul>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#step-5-funding-your-wallet","title":"Step 5: Funding your Wallet","text":"<p>Once addresses are verified, send a small test amount to your wallet. Test signing and sending a transaction before adding more funds.</p>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#step-6-sign-psbts-and-messages","title":"Step 6: Sign PSBTs and Messages","text":""},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#psbts","title":"PSBTs","text":"<ol> <li> <p>Create a transaction in your coordinator.</p> </li> <li> <p>Export the transaction as a QR code.</p> </li> <li> <p>On Krux, go to Sign -&gt; PSBT -&gt; Load from camera.</p> </li> <li> <p>Scan the animated QR code.</p> </li> <li> <p>Verify the transaction details.</p> </li> <li> <p>If correct, press <code>Sign to QR code</code>.</p> </li> <li> <p>Scan the signed transaction QR code back into the coordinator to broadcast it.</p> </li> </ol> <p>Alternatively, you can use an SD card:</p> <p>Save the transaction as a file on an SD card. On Krux, go to Sign -&gt; PSBT -&gt; Load from SD card and <code>Sign to SD card</code>. Load the signed transaction on the coordinator and broadcast it.</p>"},{"location":"getting-started/usage/setting-a-coordinator-and-signing/#messages","title":"Messages","text":"<p>Some coordinators, like Sparrow, allow you to sign messages linked to your wallet's addresses. Signing and verifying a message signature attests to the ownership of an address and serves as an additional test for your setup.</p>"}]}